<!DOCTYPE html>
<html lang="zh-cn">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <title>
  搜索结构 · fsj2009yx
</title>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="color-scheme" content="light dark">




<meta name="author" content="fsj2009yx">
<meta name="description" content="
  搜索结构
  
    
    链接到标题
  

搜索方法取决于搜索结构中数据元素的组织方式。例如，电话号码簿的搜索，可建立分类目录，采用分块（索引顺序）搜索；英汉词典是有序表，可采用折半搜索（或分块搜索）。
搜索结构分为静态搜索结构和动态搜索结构



  平均搜索长度（ASL）
  
    
    链接到标题
  

搜索过程中关键码的平均比较次数或平均读写磁盘次数



  顺序搜索
  
    
    链接到标题
  

在顺序结构查找中，可以设置监视哨以减少搜索时间。
监视哨是一个特殊的值，通常用于标记搜索的结束，避免了对数组边界的额外检查，从而简化了循环条件
template &lt;class E, class K&gt; 
int searchList&lt;E, K&gt; :: SeqSearch(const K x) const {
//顺序搜索关键码为x的数据元素, 第CurrentSize号位置
//作为控制搜索自动结束的“监视哨”使用
     Element[CurrentSize].key=x;      //设置“监视哨” 
     int i=0;
     while (Element[i].key!=x) i&#43;&#43;;     //从前向后顺序搜索
     if (i==CurrentSize) return 0;       //搜索失败
     else return i&#43;1;                              //搜索成功
}


表中最后一个元素（即 Element[CurrentSize]）的关键字设置为目标值 x。这是典型的监视哨技术的实现。


监视哨的作用是将目标值 x 放置到表的末尾，这样在执行顺序搜索时，无论目标值是否存在，都会在最后找到一个 key == x 的元素。这避免了在循环中每次都需要检查数组边界。


例如，如果目标元素 x 存在于表中，那么它将出现在某个位置 i，并且当 i 达到 CurrentSize 时，循环自然会停止。




  顺序搜索递归算法
  
    
    链接到标题
  

template &lt;class E, class K&gt; 
int searchList&lt;E, K&gt;::SeqSearch1(const K x, int loc) const {
//在搜索表中递归搜索其关键码与给定值x匹配的数据元素, 
//函数返回其表中位置。参数 loc 是在表中开始搜索位置，调用时赋初值1
    if ( loc &gt; CurrentSize ) return 0;                       //搜索失败
    else if ( Element[loc-1].key == x ) return loc;  //搜索成功
           else return SeqSearch1( x, loc&#43;1);       //继续递归搜索
}


  顺序搜索的平均搜索长度
  
    
    链接到标题
  

">
<meta name="keywords" content="blog,fsj2009yx,personal">



  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="搜索结构">
  <meta name="twitter:description" content="搜索结构链接到标题搜索方法取决于搜索结构中数据元素的组织方式。例如，电话号码簿的搜索，可建立分类目录，采用分块（索引顺序）搜索；英汉词典是有序表，可采用折半搜索（或分块搜索）。
搜索结构分为静态搜索结构和动态搜索结构
平均搜索长度（ASL）链接到标题搜索过程中关键码的平均比较次数或平均读写磁盘次数
顺序搜索链接到标题在顺序结构查找中，可以设置监视哨以减少搜索时间。
监视哨是一个特殊的值，通常用于标记搜索的结束，避免了对数组边界的额外检查，从而简化了循环条件
template &lt;class E, class K&gt; int searchList&lt;E, K&gt; :: SeqSearch(const K x) const { //顺序搜索关键码为x的数据元素, 第CurrentSize号位置 //作为控制搜索自动结束的“监视哨”使用 Element[CurrentSize].key=x; //设置“监视哨” int i=0; while (Element[i].key!=x) i&#43;&#43;; //从前向后顺序搜索 if (i==CurrentSize) return 0; //搜索失败 else return i&#43;1; //搜索成功 } 表中最后一个元素（即 Element[CurrentSize]）的关键字设置为目标值 x。这是典型的监视哨技术的实现。
监视哨的作用是将目标值 x 放置到表的末尾，这样在执行顺序搜索时，无论目标值是否存在，都会在最后找到一个 key == x 的元素。这避免了在循环中每次都需要检查数组边界。
例如，如果目标元素 x 存在于表中，那么它将出现在某个位置 i，并且当 i 达到 CurrentSize 时，循环自然会停止。
顺序搜索递归算法链接到标题template &lt;class E, class K&gt; int searchList&lt;E, K&gt;::SeqSearch1(const K x, int loc) const { //在搜索表中递归搜索其关键码与给定值x匹配的数据元素, //函数返回其表中位置。参数 loc 是在表中开始搜索位置，调用时赋初值1 if ( loc &gt; CurrentSize ) return 0; //搜索失败 else if ( Element[loc-1].key == x ) return loc; //搜索成功 else return SeqSearch1( x, loc&#43;1); //继续递归搜索 } 顺序搜索的平均搜索长度链接到标题">

<meta property="og:url" content="http://localhost:1313/posts/post/">
  <meta property="og:site_name" content="fsj2009yx">
  <meta property="og:title" content="搜索结构">
  <meta property="og:description" content="搜索结构链接到标题搜索方法取决于搜索结构中数据元素的组织方式。例如，电话号码簿的搜索，可建立分类目录，采用分块（索引顺序）搜索；英汉词典是有序表，可采用折半搜索（或分块搜索）。
搜索结构分为静态搜索结构和动态搜索结构
平均搜索长度（ASL）链接到标题搜索过程中关键码的平均比较次数或平均读写磁盘次数
顺序搜索链接到标题在顺序结构查找中，可以设置监视哨以减少搜索时间。
监视哨是一个特殊的值，通常用于标记搜索的结束，避免了对数组边界的额外检查，从而简化了循环条件
template &lt;class E, class K&gt; int searchList&lt;E, K&gt; :: SeqSearch(const K x) const { //顺序搜索关键码为x的数据元素, 第CurrentSize号位置 //作为控制搜索自动结束的“监视哨”使用 Element[CurrentSize].key=x; //设置“监视哨” int i=0; while (Element[i].key!=x) i&#43;&#43;; //从前向后顺序搜索 if (i==CurrentSize) return 0; //搜索失败 else return i&#43;1; //搜索成功 } 表中最后一个元素（即 Element[CurrentSize]）的关键字设置为目标值 x。这是典型的监视哨技术的实现。
监视哨的作用是将目标值 x 放置到表的末尾，这样在执行顺序搜索时，无论目标值是否存在，都会在最后找到一个 key == x 的元素。这避免了在循环中每次都需要检查数组边界。
例如，如果目标元素 x 存在于表中，那么它将出现在某个位置 i，并且当 i 达到 CurrentSize 时，循环自然会停止。
顺序搜索递归算法链接到标题template &lt;class E, class K&gt; int searchList&lt;E, K&gt;::SeqSearch1(const K x, int loc) const { //在搜索表中递归搜索其关键码与给定值x匹配的数据元素, //函数返回其表中位置。参数 loc 是在表中开始搜索位置，调用时赋初值1 if ( loc &gt; CurrentSize ) return 0; //搜索失败 else if ( Element[loc-1].key == x ) return loc; //搜索成功 else return SeqSearch1( x, loc&#43;1); //继续递归搜索 } 顺序搜索的平均搜索长度链接到标题">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-12-03T22:24:25+08:00">
    <meta property="article:modified_time" content="2024-12-03T22:24:25+08:00">
    <meta property="article:tag" content="数据结构">
    <meta property="article:tag" content="C&#43;&#43;">




<link rel="canonical" href="http://localhost:1313/posts/post/">


<link rel="preload" href="/fonts/fa-brands-400.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="/fonts/fa-regular-400.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="/fonts/fa-solid-900.woff2" as="font" type="font/woff2" crossorigin>


  
  
  <link rel="stylesheet" href="/css/coder.css" media="screen">






  
    
    
    <link rel="stylesheet" href="/css/coder-dark.css" media="screen">
  



 




<link rel="icon" type="image/svg+xml" href="/images/favicon.svg" sizes="any">
<link rel="icon" type="image/png" href="/images/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="/images/favicon-16x16.png" sizes="16x16">

<link rel="apple-touch-icon" href="/images/apple-touch-icon.png">
<link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">









</head>






<body class="preload-transitions colorscheme-auto">
  
<div class="float-container">
    <a id="dark-mode-toggle" class="colorscheme-toggle">
        <i class="fa-solid fa-adjust fa-fw" aria-hidden="true"></i>
    </a>
</div>


  <main class="wrapper">
    <nav class="navigation">
  <section class="container">
    
    <a class="navigation-title" href="http://localhost:1313/">
      fsj2009yx
    </a>
    
    
      <input type="checkbox" id="menu-toggle" />
      <label class="menu-button float-right" for="menu-toggle">
        <i class="fa-solid fa-bars fa-fw" aria-hidden="true"></i>
      </label>
      <ul class="navigation-list">
        
          
            <li class="navigation-item">
              <a class="navigation-link " href="/posts/">Blog</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="/categories/">Category</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="/tags/">Tags</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="/about/">About</a>
            </li>
          
        
        
      </ul>
    
  </section>
</nav>


    <div class="content">
      
  <section class="container post">
    <article>
      <header>
        <div class="post-title">
          <h1 class="title">
            <a class="title-link" href="http://localhost:1313/posts/post/">
              搜索结构
            </a>
          </h1>
        </div>
        <div class="post-meta">
          <div class="date">
            <span class="posted-on">
              <i class="fa-solid fa-calendar" aria-hidden="true"></i>
              <time datetime="2024-12-03T22:24:25&#43;08:00">
                December 3, 2024
              </time>
            </span>
            <span class="reading-time">
              <i class="fa-solid fa-clock" aria-hidden="true"></i>
              阅读时间：7 分钟
            </span>
          </div>
          <div class="authors">
  <i class="fa-solid fa-user" aria-hidden="true"></i>
    <a href="/authors/fsj2009yx/">Fsj2009yx</a></div>

          <div class="categories">
  <i class="fa-solid fa-folder" aria-hidden="true"></i>
    <a href="/categories/%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/">基础课程</a></div>

          <div class="tags">
  <i class="fa-solid fa-tag" aria-hidden="true"></i>
    <span class="tag">
      <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
    </span>
      <span class="separator">•</span>
    <span class="tag">
      <a href="/tags/c&#43;&#43;/">C&#43;&#43;</a>
    </span></div>

        </div>
      </header>

      <div class="post-content">
        
        <h1 id="搜索结构">
  搜索结构
  <a class="heading-link" href="#%e6%90%9c%e7%b4%a2%e7%bb%93%e6%9e%84">
    <i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"></i>
    <span class="sr-only">链接到标题</span>
  </a>
</h1>
<p>搜索方法取决于搜索结构中数据元素的组织方式。例如，电话号码簿的搜索，可建立分类目录，采用分块（索引顺序）搜索；英汉词典是有序表，可采用折半搜索（或分块搜索）。</p>
<p>搜索结构分为静态搜索结构和动态搜索结构</p>
<p><img src="https://cdn.jsdelivr.net/gh/fsj2009yx/picServer@main/202412021407615.png" alt="86be541cca41837e577a4d1d0bfe7694"></p>
<hr>
<h2 id="平均搜索长度asl">
  平均搜索长度（ASL）
  <a class="heading-link" href="#%e5%b9%b3%e5%9d%87%e6%90%9c%e7%b4%a2%e9%95%bf%e5%ba%a6asl">
    <i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"></i>
    <span class="sr-only">链接到标题</span>
  </a>
</h2>
<p>搜索过程中<strong>关键码的平均比较次数</strong>或<strong>平均读写磁盘次数</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/fsj2009yx/picServer@main/202412021431248.png" alt="5ae34a169d984624c05e5ed3b3b170eb"></p>
<hr>
<h2 id="顺序搜索">
  顺序搜索
  <a class="heading-link" href="#%e9%a1%ba%e5%ba%8f%e6%90%9c%e7%b4%a2">
    <i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"></i>
    <span class="sr-only">链接到标题</span>
  </a>
</h2>
<p>在顺序结构查找中，可以设置<strong>监视哨</strong>以减少搜索时间。</p>
<p>监视哨是一个特殊的值，通常用于标记搜索的结束，避免了对数组边界的额外检查，从而简化了循环条件</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#ff7b72">template</span> <span style="color:#ff7b72;font-weight:bold">&lt;</span><span style="color:#ff7b72">class</span> <span style="color:#f0883e;font-weight:bold">E</span>, <span style="color:#ff7b72">class</span> <span style="color:#f0883e;font-weight:bold">K</span><span style="color:#ff7b72;font-weight:bold">&gt;</span> 
</span></span><span style="display:flex;"><span><span style="color:#ff7b72">int</span> searchList<span style="color:#ff7b72;font-weight:bold">&lt;</span>E, K<span style="color:#ff7b72;font-weight:bold">&gt;</span> <span style="color:#ff7b72;font-weight:bold">::</span> SeqSearch(<span style="color:#ff7b72">const</span> K x) <span style="color:#ff7b72">const</span> {
</span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">//顺序搜索关键码为x的数据元素, 第CurrentSize号位置
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">//作为控制搜索自动结束的“监视哨”使用
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>     Element[CurrentSize].key<span style="color:#ff7b72;font-weight:bold">=</span>x;      <span style="color:#8b949e;font-style:italic">//设置“监视哨” 
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>     <span style="color:#ff7b72">int</span> i<span style="color:#ff7b72;font-weight:bold">=</span><span style="color:#a5d6ff">0</span>;
</span></span><span style="display:flex;"><span>     <span style="color:#ff7b72">while</span> (Element[i].key<span style="color:#ff7b72;font-weight:bold">!=</span>x) i<span style="color:#ff7b72;font-weight:bold">++</span>;     <span style="color:#8b949e;font-style:italic">//从前向后顺序搜索
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>     <span style="color:#ff7b72">if</span> (i<span style="color:#ff7b72;font-weight:bold">==</span>CurrentSize) <span style="color:#ff7b72">return</span> <span style="color:#a5d6ff">0</span>;       <span style="color:#8b949e;font-style:italic">//搜索失败
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>     <span style="color:#ff7b72">else</span> <span style="color:#ff7b72">return</span> i<span style="color:#ff7b72;font-weight:bold">+</span><span style="color:#a5d6ff">1</span>;                              <span style="color:#8b949e;font-style:italic">//搜索成功
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>}
</span></span></code></pre></div><ul>
<li>
<p>表中最后一个元素（即 <code>Element[CurrentSize]</code>）的关键字设置为目标值 <code>x</code>。这是典型的监视哨技术的实现。</p>
</li>
<li>
<p><strong>监视哨</strong>的作用是将目标值 <code>x</code> 放置到表的末尾，这样在执行顺序搜索时，无论目标值是否存在，都会在最后找到一个 <code>key == x</code> 的元素。这<strong>避免了在循环中每次都需要检查数组边界</strong>。</p>
</li>
<li>
<p>例如，如果目标元素 <code>x</code> 存在于表中，那么它将出现在某个位置 <code>i</code>，并且当 <code>i</code> 达到 <code>CurrentSize</code> 时，循环自然会停止。</p>
</li>
</ul>
<hr>
<h3 id="顺序搜索递归算法">
  顺序搜索递归算法
  <a class="heading-link" href="#%e9%a1%ba%e5%ba%8f%e6%90%9c%e7%b4%a2%e9%80%92%e5%bd%92%e7%ae%97%e6%b3%95">
    <i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"></i>
    <span class="sr-only">链接到标题</span>
  </a>
</h3>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#ff7b72">template</span> <span style="color:#ff7b72;font-weight:bold">&lt;</span><span style="color:#ff7b72">class</span> <span style="color:#f0883e;font-weight:bold">E</span>, <span style="color:#ff7b72">class</span> <span style="color:#f0883e;font-weight:bold">K</span><span style="color:#ff7b72;font-weight:bold">&gt;</span> 
</span></span><span style="display:flex;"><span><span style="color:#ff7b72">int</span> searchList<span style="color:#ff7b72;font-weight:bold">&lt;</span>E, K<span style="color:#ff7b72;font-weight:bold">&gt;::</span>SeqSearch1(<span style="color:#ff7b72">const</span> K x, <span style="color:#ff7b72">int</span> loc) <span style="color:#ff7b72">const</span> {
</span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">//在搜索表中递归搜索其关键码与给定值x匹配的数据元素, 
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">//函数返回其表中位置。参数 loc 是在表中开始搜索位置，调用时赋初值1
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>    <span style="color:#ff7b72">if</span> ( loc <span style="color:#ff7b72;font-weight:bold">&gt;</span> CurrentSize ) <span style="color:#ff7b72">return</span> <span style="color:#a5d6ff">0</span>;                       <span style="color:#8b949e;font-style:italic">//搜索失败
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>    <span style="color:#ff7b72">else</span> <span style="color:#d2a8ff;font-weight:bold">if</span> ( Element[loc<span style="color:#ff7b72;font-weight:bold">-</span><span style="color:#a5d6ff">1</span>].key <span style="color:#ff7b72;font-weight:bold">==</span> x ) <span style="color:#ff7b72">return</span> loc;  <span style="color:#8b949e;font-style:italic">//搜索成功
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>           <span style="color:#ff7b72">else</span> <span style="color:#ff7b72">return</span> <span style="color:#d2a8ff;font-weight:bold">SeqSearch1</span>( x, loc<span style="color:#ff7b72;font-weight:bold">+</span><span style="color:#a5d6ff">1</span>);       <span style="color:#8b949e;font-style:italic">//继续递归搜索
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>}
</span></span></code></pre></div><hr>
<h3 id="顺序搜索的平均搜索长度">
  顺序搜索的平均搜索长度
  <a class="heading-link" href="#%e9%a1%ba%e5%ba%8f%e6%90%9c%e7%b4%a2%e7%9a%84%e5%b9%b3%e5%9d%87%e6%90%9c%e7%b4%a2%e9%95%bf%e5%ba%a6">
    <i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"></i>
    <span class="sr-only">链接到标题</span>
  </a>
</h3>
<p><img src="https://cdn.jsdelivr.net/gh/fsj2009yx/picServer@main/202412021432877.png" alt="e6531cd3962e677cbfc4a91a1e4ccd5f"></p>
<hr>
<h2 id="折半搜索">
  折半搜索
  <a class="heading-link" href="#%e6%8a%98%e5%8d%8a%e6%90%9c%e7%b4%a2">
    <i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"></i>
    <span class="sr-only">链接到标题</span>
  </a>
</h2>
<p>折半搜索即<strong>二分查找</strong>，不多加以解释，附上代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#ff7b72">int</span> <span style="color:#d2a8ff;font-weight:bold">binarySearch</span>(vector<span style="color:#ff7b72;font-weight:bold">&lt;</span><span style="color:#ff7b72">int</span><span style="color:#ff7b72;font-weight:bold">&gt;</span> <span style="color:#ff7b72;font-weight:bold">&amp;</span>arr, <span style="color:#ff7b72">int</span> left, <span style="color:#ff7b72">int</span> right, <span style="color:#ff7b72">int</span> target)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#ff7b72">int</span> mid;
</span></span><span style="display:flex;"><span>    <span style="color:#ff7b72">while</span> (left <span style="color:#ff7b72;font-weight:bold">&lt;</span> right)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        mid <span style="color:#ff7b72;font-weight:bold">=</span> left <span style="color:#ff7b72;font-weight:bold">+</span> (right <span style="color:#ff7b72;font-weight:bold">-</span> left) <span style="color:#ff7b72;font-weight:bold">/</span> <span style="color:#a5d6ff">2</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ff7b72">if</span> (arr[mid] <span style="color:#ff7b72;font-weight:bold">==</span> target)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#ff7b72">return</span> mid; <span style="color:#8b949e;font-style:italic">// 找到
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#ff7b72">else</span> <span style="color:#ff7b72">if</span> (arr[mid] <span style="color:#ff7b72;font-weight:bold">&lt;</span> target) <span style="color:#8b949e;font-style:italic">// 说明在右边
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>        {
</span></span><span style="display:flex;"><span>            left <span style="color:#ff7b72;font-weight:bold">=</span> mid <span style="color:#ff7b72;font-weight:bold">+</span> <span style="color:#a5d6ff">1</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#ff7b72">else</span> <span style="color:#8b949e;font-style:italic">// 说明在左边
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>        {
</span></span><span style="display:flex;"><span>            right <span style="color:#ff7b72;font-weight:bold">=</span> mid;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff7b72">return</span> <span style="color:#ff7b72;font-weight:bold">-</span><span style="color:#a5d6ff">1</span>; <span style="color:#8b949e;font-style:italic">// 未找到
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>}
</span></span></code></pre></div><p>注意：在二分查找前必须保证顺序表是<strong>有序</strong>的，即按照<strong>递增或递减</strong>（代码中为递增）排列</p>
<p><strong>BST（Binary Search Tree）、AVL 树和红黑树（RB 树）的底层逻辑都基于折半搜索</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/fsj2009yx/picServer@main/202412021441349.png" alt="84134312fc164b88232544ee30945bc4"></p>
<hr>
<h2 id="分块搜索">
  分块搜索
  <a class="heading-link" href="#%e5%88%86%e5%9d%97%e6%90%9c%e7%b4%a2">
    <i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"></i>
    <span class="sr-only">链接到标题</span>
  </a>
</h2>
<p>分块查找，也称为<strong>块搜索或索引-顺序搜索</strong>，是一种常见的查找算法，主要用于在已排序的数据块或块中快速定位目标元素。它结合了顺序查找和二分查找的优点，并使得在大规模数据集中进行查找更加高效。</p>
<p><strong>分块查找的基本思想是将数据划分为多个块，并对每个块进行排序。</strong></p>
<p>分块查找的优点是在执行查找时可以跳过一些不必要的块，从而提高查找效率。它适用于<strong>静态数据集（即不经常更新的数据集）<strong>以及对</strong>内存敏感的应用程序</strong>。然而，由于需要预处理数据集，因此在数据集经常变化的情况下，它的效率可能会降低。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fsj2009yx/picServer@main/202412021447085.png" alt="9fad68e57d425d9f218a48c92573ed97"></p>
<hr>
<h3 id="算法工作流程">
  算法工作流程
  <a class="heading-link" href="#%e7%ae%97%e6%b3%95%e5%b7%a5%e4%bd%9c%e6%b5%81%e7%a8%8b">
    <i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"></i>
    <span class="sr-only">链接到标题</span>
  </a>
</h3>
<p><strong>分块预处理</strong></p>
<ul>
<li><strong>将数据分成多个块</strong>：首先，将整个数据集分成多个较小的块。每个块的大小相同，通常是一个固定的大小。例如，图中展示的将数据划分为 4 个块，每个块包含 5 个元素。</li>
<li><strong>构建块的标识</strong>：为了加速搜索，可以为每个块记录一个<strong>块的最大值</strong>或<strong>最小值</strong>（通常是最大值），用作块的“代表值”。这些代表值将被用来决定哪个块可能包含目标元素。例如，图中每个块的最大值会被存储，以便快速定位可能的块。</li>
</ul>
<p><strong>块的选择</strong></p>
<ul>
<li><strong>首先使用代表值进行搜索</strong>：在搜索时，首先通过比较目标值 <code>x</code> 和每个块的代表值来确定目标值可能在哪个块中。也就是说，你首先检查目标值与各个块的代表值进行比较，寻找目标值所在的块。</li>
<li><strong>定位目标块</strong>：例如，如果目标值 <code>x</code> 小于第一个块的最大值，但大于第二个块的最大值，则可以确定目标值在第二个块中。</li>
</ul>
<p><strong>在块内线性查找</strong></p>
<ul>
<li><strong>块内搜索</strong>：一旦确定目标值位于某个块内，接下来只需要对该块进行线性搜索（顺序查找）。由于块内的元素较少，线性查找相较于全局查找会更高效。</li>
<li><strong>查找成功或失败</strong>：如果在块内找到目标元素，搜索成功。如果块内没有找到目标元素，则可以搜索下一个块，直到找到目标值或搜索结束。</li>
</ul>
<hr>
<h3 id="代码示例">
  代码示例
  <a class="heading-link" href="#%e4%bb%a3%e7%a0%81%e7%a4%ba%e4%be%8b">
    <i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"></i>
    <span class="sr-only">链接到标题</span>
  </a>
</h3>
<p>定义一个方法利用分块查找，数据如下：{16, 5, 9, 12,21, 18, 32, 23, 37, 26, 45, 34, 50, 48, 61, 52, 73, 66}</p>
<p>要求：查询某个元素是否存在</p>
<p>代码如下（JAVA）：</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#ff7b72">package</span><span style="color:#6e7681"> </span><span style="color:#ff7b72">text.text02</span>;<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681"></span><span style="color:#8b949e;font-style:italic">/*
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">分块查找：
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">    当数据表中的数据元素很多时，可以采用分块查找。汲取了顺序查找和折半查找各自的优点，既有动态结构，又适于快速查找
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">    
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">分块查找适用于数据较多，但是数据不会发生变化的情况。
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">分块查找的过程：
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">    1. 需要把数据分成N多小块，块与块之间不能有数据重复的交集。
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">    2. 给每一块创建对象单独存储到数组当中
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">    3. 查找数据的时候，先在数组查，当前数据属于哪一块
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">    4. 再到这一块中顺序查找
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"> */</span><span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681"></span><span style="color:#ff7b72">public</span><span style="color:#6e7681"> </span><span style="color:#ff7b72">class</span> <span style="color:#f0883e;font-weight:bold">text10A</span><span style="color:#6e7681"> </span>{<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">    </span><span style="color:#ff7b72">public</span><span style="color:#6e7681"> </span><span style="color:#ff7b72">static</span><span style="color:#6e7681"> </span><span style="color:#ff7b72">void</span><span style="color:#6e7681"> </span><span style="color:#d2a8ff;font-weight:bold">main</span>(String<span style="color:#ff7b72;font-weight:bold">[]</span><span style="color:#6e7681"> </span>args)<span style="color:#6e7681"> </span>{<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">        </span><span style="color:#8b949e;font-style:italic">//定义个数组存储所有元素</span><span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">        </span><span style="color:#ff7b72">int</span><span style="color:#ff7b72;font-weight:bold">[]</span><span style="color:#6e7681"> </span>arr<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">=</span><span style="color:#6e7681"> </span>{16,<span style="color:#6e7681"> </span>5,<span style="color:#6e7681"> </span>9,<span style="color:#6e7681"> </span>12,<span style="color:#6e7681"> </span>21,<span style="color:#6e7681"> </span>18,<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">                </span>32,<span style="color:#6e7681"> </span>23,<span style="color:#6e7681"> </span>37,<span style="color:#6e7681"> </span>26,<span style="color:#6e7681"> </span>45,<span style="color:#6e7681"> </span>34,<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">                </span>50,<span style="color:#6e7681"> </span>48,<span style="color:#6e7681"> </span>61,<span style="color:#6e7681"> </span>52,<span style="color:#6e7681"> </span>73,<span style="color:#6e7681"> </span>66};<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">        </span><span style="color:#8b949e;font-style:italic">//定义两个要查询的数（一个能查到，一个查不到）</span><span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">        </span><span style="color:#ff7b72">int</span><span style="color:#6e7681"> </span>number1<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">=</span><span style="color:#6e7681"> </span>23;<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">        </span><span style="color:#ff7b72">int</span><span style="color:#6e7681"> </span>number2<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">=</span><span style="color:#6e7681"> </span>49;<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">        </span><span style="color:#8b949e;font-style:italic">//创建块对象，将arr数组按照一定的规律分块(块内无序，块间有序)</span><span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">        </span>Block<span style="color:#6e7681"> </span>block1<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">=</span><span style="color:#6e7681"> </span><span style="color:#ff7b72">new</span><span style="color:#6e7681"> </span>Block(21,<span style="color:#6e7681"> </span>0,<span style="color:#6e7681"> </span>5);<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">        </span>Block<span style="color:#6e7681"> </span>block2<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">=</span><span style="color:#6e7681"> </span><span style="color:#ff7b72">new</span><span style="color:#6e7681"> </span>Block(45,<span style="color:#6e7681"> </span>6,<span style="color:#6e7681"> </span>11);<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">        </span>Block<span style="color:#6e7681"> </span>block3<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">=</span><span style="color:#6e7681"> </span><span style="color:#ff7b72">new</span><span style="color:#6e7681"> </span>Block(73,<span style="color:#6e7681"> </span>12,<span style="color:#6e7681"> </span>17);<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">        </span><span style="color:#8b949e;font-style:italic">//定义数组，将块对象添加进数组</span><span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">        </span>Block<span style="color:#ff7b72;font-weight:bold">[]</span><span style="color:#6e7681"> </span>blocks<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">=</span><span style="color:#6e7681"> </span>{block1,<span style="color:#6e7681"> </span>block2,<span style="color:#6e7681"> </span>block3};<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">        </span>System.out.println(<span style="color:#a5d6ff">&#34;==========基本查找/顺序查找==========&#34;</span>);<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">        </span><span style="color:#8b949e;font-style:italic">//调用judgeIndex1方法，判断要查询的数在块对象中的索引 （judgeIndex1方法用的是基本查找）</span><span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">        </span><span style="color:#ff7b72">int</span><span style="color:#6e7681"> </span>index1<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">=</span><span style="color:#6e7681"> </span>judgeIndex1(blocks,<span style="color:#6e7681"> </span>number1);<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">        </span><span style="color:#ff7b72">int</span><span style="color:#6e7681"> </span>index2<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">=</span><span style="color:#6e7681"> </span>judgeIndex1(blocks,<span style="color:#6e7681"> </span>number2);<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">        </span><span style="color:#8b949e;font-style:italic">//调用judgeNumber方法，根据judgeIndex1方法返回的索引判断要查询的数在该arr数组中是否存在</span><span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">        </span>judgeNumber(arr,<span style="color:#6e7681"> </span>blocks,<span style="color:#6e7681"> </span>index1,<span style="color:#6e7681"> </span>number1);<span style="color:#6e7681">    </span><span style="color:#8b949e;font-style:italic">//23存在，该数在数组中的索引为：7</span><span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">        </span>judgeNumber(arr,<span style="color:#6e7681"> </span>blocks,<span style="color:#6e7681"> </span>index2,<span style="color:#6e7681"> </span>number2);<span style="color:#6e7681">    </span><span style="color:#8b949e;font-style:italic">//49不存在</span><span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">        </span>System.out.println(<span style="color:#a5d6ff">&#34;==========二分查找/折半查找==========&#34;</span>);<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">        </span><span style="color:#8b949e;font-style:italic">// 调用judgeIndex2方法，判断要查询的数在块对象中的索引 （judgeIndex2方法用的是折半查找/二分查找）</span><span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">        </span><span style="color:#ff7b72">int</span><span style="color:#6e7681"> </span>index3<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">=</span><span style="color:#6e7681"> </span>judgeIndex2(blocks,<span style="color:#6e7681"> </span>number1);<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">        </span><span style="color:#ff7b72">int</span><span style="color:#6e7681"> </span>index4<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">=</span><span style="color:#6e7681"> </span>judgeIndex2(blocks,<span style="color:#6e7681"> </span>number2);<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">        </span><span style="color:#8b949e;font-style:italic">//调用judgeNumber方法，根据judgeIndex2方法返回的索引判断要查询的数在该arr数组中是否存在</span><span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">        </span>judgeNumber(arr,<span style="color:#6e7681"> </span>blocks,<span style="color:#6e7681"> </span>index1,<span style="color:#6e7681"> </span>number1);<span style="color:#6e7681">    </span><span style="color:#8b949e;font-style:italic">//23存在，该数在数组中的索引为：7</span><span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">        </span>judgeNumber(arr,<span style="color:#6e7681"> </span>blocks,<span style="color:#6e7681"> </span>index2,<span style="color:#6e7681"> </span>number2);<span style="color:#6e7681">    </span><span style="color:#8b949e;font-style:italic">//49不存在</span><span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">    </span>}<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">    </span><span style="color:#8b949e;font-style:italic">//创建方法，判断要查询的数在哪块对象中，即在块对象中的索引（基本查找/顺序查找）</span><span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">    </span><span style="color:#ff7b72">public</span><span style="color:#6e7681"> </span><span style="color:#ff7b72">static</span><span style="color:#6e7681"> </span><span style="color:#ff7b72">int</span><span style="color:#6e7681"> </span><span style="color:#d2a8ff;font-weight:bold">judgeIndex1</span>(Block<span style="color:#ff7b72;font-weight:bold">[]</span><span style="color:#6e7681"> </span>blocks,<span style="color:#6e7681"> </span><span style="color:#ff7b72">int</span><span style="color:#6e7681"> </span>number)<span style="color:#6e7681"> </span>{<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">        </span><span style="color:#8b949e;font-style:italic">//利用循环遍历块对象数组，查找要查询的数的索引</span><span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">        </span><span style="color:#ff7b72">for</span><span style="color:#6e7681"> </span>(<span style="color:#ff7b72">int</span><span style="color:#6e7681"> </span>i<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">=</span><span style="color:#6e7681"> </span>0;<span style="color:#6e7681"> </span>i<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">&lt;</span><span style="color:#6e7681"> </span>blocks.length;<span style="color:#6e7681"> </span>i<span style="color:#ff7b72;font-weight:bold">++</span>)<span style="color:#6e7681"> </span>{<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">            </span><span style="color:#8b949e;font-style:italic">//如果要查询的数小于该块对象中的最大值</span><span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">            </span><span style="color:#ff7b72">if</span><span style="color:#6e7681"> </span>(number<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">&lt;=</span><span style="color:#6e7681"> </span>blocks<span style="color:#ff7b72;font-weight:bold">[</span>i<span style="color:#ff7b72;font-weight:bold">]</span>.getMax())<span style="color:#6e7681"> </span>{<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">                </span><span style="color:#8b949e;font-style:italic">//返回该块对象的索引</span><span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">                </span><span style="color:#ff7b72">return</span><span style="color:#6e7681"> </span>i;<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">            </span>}<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">        </span>}<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">        </span><span style="color:#ff7b72">return</span><span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">-</span>1;<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">    </span>}<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">    </span><span style="color:#8b949e;font-style:italic">//创建方法，判断要查询的数在哪块对象中，即在块对象中的索引（折半查找/二分查找）</span><span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">    </span><span style="color:#ff7b72">public</span><span style="color:#6e7681"> </span><span style="color:#ff7b72">static</span><span style="color:#6e7681"> </span><span style="color:#ff7b72">int</span><span style="color:#6e7681"> </span><span style="color:#d2a8ff;font-weight:bold">judgeIndex2</span>(Block<span style="color:#ff7b72;font-weight:bold">[]</span><span style="color:#6e7681"> </span>blocks,<span style="color:#6e7681"> </span><span style="color:#ff7b72">int</span><span style="color:#6e7681"> </span>number)<span style="color:#6e7681"> </span>{<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">        </span><span style="color:#8b949e;font-style:italic">//折半查找中的起始索引</span><span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">        </span><span style="color:#ff7b72">int</span><span style="color:#6e7681"> </span>min<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">=</span><span style="color:#6e7681"> </span>0;<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">        </span><span style="color:#8b949e;font-style:italic">//折半查找中的结束索引</span><span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">        </span><span style="color:#ff7b72">int</span><span style="color:#6e7681"> </span>max<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">=</span><span style="color:#6e7681"> </span>blocks.length<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">-</span><span style="color:#6e7681"> </span>1;<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">        </span><span style="color:#8b949e;font-style:italic">//折半查找中的中间索引</span><span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">        </span><span style="color:#ff7b72">int</span><span style="color:#6e7681"> </span>mid<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">=</span><span style="color:#6e7681"> </span>(min<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">+</span><span style="color:#6e7681"> </span>max)<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">/</span><span style="color:#6e7681"> </span>2;<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">        </span><span style="color:#8b949e;font-style:italic">//利用循环查找要查找的数在块对象数组中的索引</span><span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">        </span><span style="color:#ff7b72">while</span><span style="color:#6e7681"> </span>(<span style="color:#79c0ff">true</span>)<span style="color:#6e7681"> </span>{<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">            </span><span style="color:#8b949e;font-style:italic">//如果起始索引小于结束索引，表明没找到</span><span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">            </span><span style="color:#ff7b72">if</span><span style="color:#6e7681"> </span>(min<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">&lt;</span><span style="color:#6e7681"> </span>max)<span style="color:#6e7681"> </span>{<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">                </span><span style="color:#ff7b72">return</span><span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">-</span>1;<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">            </span>}<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">            </span><span style="color:#8b949e;font-style:italic">//如果要查找的数大于块对象数组中间索引的最大值</span><span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">            </span><span style="color:#ff7b72">if</span><span style="color:#6e7681"> </span>(number<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">&gt;</span><span style="color:#6e7681"> </span>blocks<span style="color:#ff7b72;font-weight:bold">[</span>mid<span style="color:#ff7b72;font-weight:bold">]</span>.getMax())<span style="color:#6e7681"> </span>{<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">                </span>min<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">=</span><span style="color:#6e7681"> </span>mid<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">+</span><span style="color:#6e7681"> </span>1;<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">            </span>}<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">            </span><span style="color:#8b949e;font-style:italic">//如果要查找的数小于块对象数组中间索引-1的最小值</span><span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">            </span><span style="color:#ff7b72">else</span><span style="color:#6e7681"> </span><span style="color:#ff7b72">if</span><span style="color:#6e7681"> </span>(number<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">&lt;</span><span style="color:#6e7681"> </span>blocks<span style="color:#ff7b72;font-weight:bold">[</span>mid<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">-</span><span style="color:#6e7681"> </span>1<span style="color:#ff7b72;font-weight:bold">]</span>.getMax())<span style="color:#6e7681"> </span>{<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">                </span>max<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">=</span><span style="color:#6e7681"> </span>mid<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">-</span><span style="color:#6e7681"> </span>1;<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">            </span>}<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">            </span><span style="color:#8b949e;font-style:italic">//如果要查找的数大于块对象数组中间索引-1的最小值并且小于块对象数组中间索引的最大值</span><span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">            </span><span style="color:#ff7b72">else</span><span style="color:#6e7681"> </span><span style="color:#ff7b72">if</span><span style="color:#6e7681"> </span>(number<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">&lt;</span><span style="color:#6e7681"> </span>blocks<span style="color:#ff7b72;font-weight:bold">[</span>mid<span style="color:#ff7b72;font-weight:bold">]</span>.getMax()<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">&amp;</span><span style="color:#6e7681"> </span>number<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">&gt;</span><span style="color:#6e7681"> </span>blocks<span style="color:#ff7b72;font-weight:bold">[</span>mid<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">-</span><span style="color:#6e7681"> </span>1<span style="color:#ff7b72;font-weight:bold">]</span>.getMax())<span style="color:#6e7681"> </span>{<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">                </span><span style="color:#ff7b72">return</span><span style="color:#6e7681"> </span>mid;<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">            </span>}<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">        </span>}<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">    </span>}<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">    </span><span style="color:#8b949e;font-style:italic">//创建方法，判断要查找的数在judgeIndex块对象中已经确定的块对象区域中是否存在</span><span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">    </span><span style="color:#ff7b72">public</span><span style="color:#6e7681"> </span><span style="color:#ff7b72">static</span><span style="color:#6e7681"> </span><span style="color:#ff7b72">void</span><span style="color:#6e7681"> </span><span style="color:#d2a8ff;font-weight:bold">judgeNumber</span>(<span style="color:#ff7b72">int</span><span style="color:#ff7b72;font-weight:bold">[]</span><span style="color:#6e7681"> </span>arr,<span style="color:#6e7681"> </span>Block<span style="color:#ff7b72;font-weight:bold">[]</span><span style="color:#6e7681"> </span>blocks,<span style="color:#6e7681"> </span><span style="color:#ff7b72">int</span><span style="color:#6e7681"> </span>index,<span style="color:#6e7681"> </span><span style="color:#ff7b72">int</span><span style="color:#6e7681"> </span>number)<span style="color:#6e7681"> </span>{<span style="color:#6e7681">  </span><span style="color:#8b949e;font-style:italic">//index为blocks块对象数组中的索引</span><span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">        </span><span style="color:#ff7b72">for</span><span style="color:#6e7681"> </span>(<span style="color:#ff7b72">int</span><span style="color:#6e7681"> </span>i<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">=</span><span style="color:#6e7681"> </span>blocks<span style="color:#ff7b72;font-weight:bold">[</span>index<span style="color:#ff7b72;font-weight:bold">]</span>.getStartIndex();<span style="color:#6e7681"> </span>i<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">&lt;=</span><span style="color:#6e7681"> </span>blocks<span style="color:#ff7b72;font-weight:bold">[</span>index<span style="color:#ff7b72;font-weight:bold">]</span>.getEndIndex();<span style="color:#6e7681"> </span>i<span style="color:#ff7b72;font-weight:bold">++</span>)<span style="color:#6e7681"> </span>{<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">            </span><span style="color:#ff7b72">if</span><span style="color:#6e7681"> </span>(arr<span style="color:#ff7b72;font-weight:bold">[</span>i<span style="color:#ff7b72;font-weight:bold">]</span><span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">==</span><span style="color:#6e7681"> </span>number)<span style="color:#6e7681"> </span>{<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">                </span>System.out.println(number<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">+</span><span style="color:#6e7681"> </span><span style="color:#a5d6ff">&#34;存在，该数在数组中的索引为：&#34;</span><span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">+</span><span style="color:#6e7681"> </span>i);<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">                </span><span style="color:#ff7b72">return</span>;<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">            </span>}<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">        </span>}<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">        </span>System.out.println(number<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">+</span><span style="color:#6e7681"> </span><span style="color:#a5d6ff">&#34;不存在&#34;</span>);<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">    </span>}<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681"></span>}<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681"></span><span style="color:#8b949e;font-style:italic">//创建块类</span><span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681"></span><span style="color:#ff7b72">class</span> <span style="color:#f0883e;font-weight:bold">Block</span><span style="color:#6e7681"> </span>{<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">    </span><span style="color:#8b949e;font-style:italic">//定义一个变量记录每块中的最大值</span><span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">    </span><span style="color:#ff7b72">private</span><span style="color:#6e7681"> </span><span style="color:#ff7b72">int</span><span style="color:#6e7681"> </span>max;<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">    </span><span style="color:#8b949e;font-style:italic">//定义一个变量记录每块中的起始索引</span><span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">    </span><span style="color:#ff7b72">private</span><span style="color:#6e7681"> </span><span style="color:#ff7b72">int</span><span style="color:#6e7681"> </span>startIndex;<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">    </span><span style="color:#8b949e;font-style:italic">//定义一个变量记录每块中的结束索引</span><span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">    </span><span style="color:#ff7b72">private</span><span style="color:#6e7681"> </span><span style="color:#ff7b72">int</span><span style="color:#6e7681"> </span>endIndex;<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">    </span><span style="color:#ff7b72">public</span><span style="color:#6e7681"> </span><span style="color:#d2a8ff;font-weight:bold">Block</span>()<span style="color:#6e7681"> </span>{<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">    </span>}<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">    </span><span style="color:#ff7b72">public</span><span style="color:#6e7681"> </span><span style="color:#d2a8ff;font-weight:bold">Block</span>(<span style="color:#ff7b72">int</span><span style="color:#6e7681"> </span>max,<span style="color:#6e7681"> </span><span style="color:#ff7b72">int</span><span style="color:#6e7681"> </span>startIndex,<span style="color:#6e7681"> </span><span style="color:#ff7b72">int</span><span style="color:#6e7681"> </span>endIndex)<span style="color:#6e7681"> </span>{<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">        </span><span style="color:#ff7b72">this</span>.max<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">=</span><span style="color:#6e7681"> </span>max;<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">        </span><span style="color:#ff7b72">this</span>.startIndex<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">=</span><span style="color:#6e7681"> </span>startIndex;<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">        </span><span style="color:#ff7b72">this</span>.endIndex<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">=</span><span style="color:#6e7681"> </span>endIndex;<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">    </span>}<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">    </span><span style="color:#8b949e;font-style:italic">/**
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">     * 获取
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">     *
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">     * @return max
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">     */</span><span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">    </span><span style="color:#ff7b72">public</span><span style="color:#6e7681"> </span><span style="color:#ff7b72">int</span><span style="color:#6e7681"> </span><span style="color:#d2a8ff;font-weight:bold">getMax</span>()<span style="color:#6e7681"> </span>{<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">        </span><span style="color:#ff7b72">return</span><span style="color:#6e7681"> </span>max;<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">    </span>}<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">    </span><span style="color:#8b949e;font-style:italic">/**
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">     * 设置
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">     *
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">     * @param max
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">     */</span><span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">    </span><span style="color:#ff7b72">public</span><span style="color:#6e7681"> </span><span style="color:#ff7b72">void</span><span style="color:#6e7681"> </span><span style="color:#d2a8ff;font-weight:bold">setMax</span>(<span style="color:#ff7b72">int</span><span style="color:#6e7681"> </span>max)<span style="color:#6e7681"> </span>{<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">        </span><span style="color:#ff7b72">this</span>.max<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">=</span><span style="color:#6e7681"> </span>max;<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">    </span>}<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">    </span><span style="color:#8b949e;font-style:italic">/**
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">     * 获取
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">     *
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">     * @return startIndex
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">     */</span><span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">    </span><span style="color:#ff7b72">public</span><span style="color:#6e7681"> </span><span style="color:#ff7b72">int</span><span style="color:#6e7681"> </span><span style="color:#d2a8ff;font-weight:bold">getStartIndex</span>()<span style="color:#6e7681"> </span>{<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">        </span><span style="color:#ff7b72">return</span><span style="color:#6e7681"> </span>startIndex;<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">    </span>}<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">    </span><span style="color:#8b949e;font-style:italic">/**
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">     * 设置
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">     *
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">     * @param startIndex
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">     */</span><span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">    </span><span style="color:#ff7b72">public</span><span style="color:#6e7681"> </span><span style="color:#ff7b72">void</span><span style="color:#6e7681"> </span><span style="color:#d2a8ff;font-weight:bold">setStartIndex</span>(<span style="color:#ff7b72">int</span><span style="color:#6e7681"> </span>startIndex)<span style="color:#6e7681"> </span>{<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">        </span><span style="color:#ff7b72">this</span>.startIndex<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">=</span><span style="color:#6e7681"> </span>startIndex;<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">    </span>}<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">    </span><span style="color:#8b949e;font-style:italic">/**
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">     * 获取
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">     *
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">     * @return endIndex
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">     */</span><span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">    </span><span style="color:#ff7b72">public</span><span style="color:#6e7681"> </span><span style="color:#ff7b72">int</span><span style="color:#6e7681"> </span><span style="color:#d2a8ff;font-weight:bold">getEndIndex</span>()<span style="color:#6e7681"> </span>{<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">        </span><span style="color:#ff7b72">return</span><span style="color:#6e7681"> </span>endIndex;<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">    </span>}<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">    </span><span style="color:#8b949e;font-style:italic">/**
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">     * 设置
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">     *
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">     * @param endIndex
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">     */</span><span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">    </span><span style="color:#ff7b72">public</span><span style="color:#6e7681"> </span><span style="color:#ff7b72">void</span><span style="color:#6e7681"> </span><span style="color:#d2a8ff;font-weight:bold">setEndIndex</span>(<span style="color:#ff7b72">int</span><span style="color:#6e7681"> </span>endIndex)<span style="color:#6e7681"> </span>{<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">        </span><span style="color:#ff7b72">this</span>.endIndex<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">=</span><span style="color:#6e7681"> </span>endIndex;<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">    </span>}<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">    </span><span style="color:#ff7b72">public</span><span style="color:#6e7681"> </span>String<span style="color:#6e7681"> </span><span style="color:#d2a8ff;font-weight:bold">toString</span>()<span style="color:#6e7681"> </span>{<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">        </span><span style="color:#ff7b72">return</span><span style="color:#6e7681"> </span><span style="color:#a5d6ff">&#34;Block{max = &#34;</span><span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">+</span><span style="color:#6e7681"> </span>max<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">+</span><span style="color:#6e7681"> </span><span style="color:#a5d6ff">&#34;, startIndex = &#34;</span><span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">+</span><span style="color:#6e7681"> </span>startIndex<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">+</span><span style="color:#6e7681"> </span><span style="color:#a5d6ff">&#34;, endIndex = &#34;</span><span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">+</span><span style="color:#6e7681"> </span>endIndex<span style="color:#6e7681"> </span><span style="color:#ff7b72;font-weight:bold">+</span><span style="color:#6e7681"> </span><span style="color:#a5d6ff">&#34;}&#34;</span>;<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681">    </span>}<span style="color:#6e7681">
</span></span></span><span style="display:flex;"><span><span style="color:#6e7681"></span>}<span style="color:#6e7681">
</span></span></span></code></pre></div><hr>
<h3 id="分块搜索性能分析">
  <strong>分块搜索性能分析</strong>
  <a class="heading-link" href="#%e5%88%86%e5%9d%97%e6%90%9c%e7%b4%a2%e6%80%a7%e8%83%bd%e5%88%86%e6%9e%90">
    <i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"></i>
    <span class="sr-only">链接到标题</span>
  </a>
</h3>
<p><img src="https://cdn.jsdelivr.net/gh/fsj2009yx/picServer@main/202412021457360.png" alt="fbbf1f9833e584d3b6f87971ca30bc28"></p>
<hr>
<h2 id="二叉搜索树bst">
  二叉搜索树（BST）
  <a class="heading-link" href="#%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91bst">
    <i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"></i>
    <span class="sr-only">链接到标题</span>
  </a>
</h2>
<h3 id="bst基本概念">
  BST基本概念
  <a class="heading-link" href="#bst%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5">
    <i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"></i>
    <span class="sr-only">链接到标题</span>
  </a>
</h3>
<h4 id="二叉搜索树的定义">
  二叉搜索树的定义
  <a class="heading-link" href="#%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91%e7%9a%84%e5%ae%9a%e4%b9%89">
    <i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"></i>
    <span class="sr-only">链接到标题</span>
  </a>
</h4>
<ul>
<li>若它的左子树不空，则左子树上所有结点的值均小于它根结点的值。</li>
<li>若它的右子树不空，则右子树上所有结点的值均大于它根结点的值。</li>
<li>它的左、右树又分为⼆叉排序树</li>
</ul>
<h4 id="二叉搜索树的性质">
  二叉搜索树的性质
  <a class="heading-link" href="#%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91%e7%9a%84%e6%80%a7%e8%b4%a8">
    <i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"></i>
    <span class="sr-only">链接到标题</span>
  </a>
</h4>
<ul>
<li>
<p><strong>中序遍历该树可以按从小到大的顺序将各个结点的关键码排列起来</strong>。所以二叉搜索树也称为二叉排序树。</p>
<ul>
<li>（<strong>注：<strong>这可以作为</strong>判断一棵二叉树是否为二叉搜索树</strong>的方法！）</li>
</ul>
</li>
<li>
<p>若从根结点到某个叶结点有一条路径，则路径上经过的结点的关键码不一定构成一个有序序列。</p>
</li>
</ul>
<hr>
<h3 id="bst搜索算法">
  BST搜索算法
  <a class="heading-link" href="#bst%e6%90%9c%e7%b4%a2%e7%ae%97%e6%b3%95">
    <i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"></i>
    <span class="sr-only">链接到标题</span>
  </a>
</h3>
<h4 id="基本思想">
  基本思想
  <a class="heading-link" href="#%e5%9f%ba%e6%9c%ac%e6%80%9d%e6%83%b3">
    <i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"></i>
    <span class="sr-only">链接到标题</span>
  </a>
</h4>
<p>假设要搜索关键码为x的元素，<strong>先从根结点开始</strong>，如果根指针为空，则搜索失败；否则将给定值x与根结点的关键码进行比较：</p>
<ul>
<li>
<p>如果 x等于根结点的关键码，则搜索成功，返回搜索到的结点地址；</p>
</li>
<li>
<p>如果 x<strong>小于</strong>根结点的关键码，则在<strong>左子树</strong>中继续搜索；</p>
</li>
<li>
<p>如果 x<strong>大于</strong>根结点的关键码，则在<strong>右子树</strong>中继续搜索。</p>
</li>
</ul>
<p>二叉搜索树的效率就在于只需搜索两个子树之一。</p>
<p>给出<strong>递归</strong>和<strong>非递归</strong>代码：</p>
<p>递归实现：</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#ff7b72">template</span> <span style="color:#ff7b72;font-weight:bold">&lt;</span><span style="color:#ff7b72">class</span> <span style="color:#f0883e;font-weight:bold">E</span>, <span style="color:#ff7b72">class</span> <span style="color:#f0883e;font-weight:bold">K</span><span style="color:#ff7b72;font-weight:bold">&gt;</span> 
</span></span><span style="display:flex;"><span>BSTNode<span style="color:#ff7b72;font-weight:bold">&lt;</span>E, K<span style="color:#ff7b72;font-weight:bold">&gt;</span> <span style="color:#ff7b72;font-weight:bold">*</span>BST<span style="color:#ff7b72;font-weight:bold">&lt;</span>E, K<span style="color:#ff7b72;font-weight:bold">&gt;</span> <span style="color:#ff7b72;font-weight:bold">::</span> Search( <span style="color:#ff7b72">const</span> K x, BSTNode<span style="color:#ff7b72;font-weight:bold">&lt;</span>E, K<span style="color:#ff7b72;font-weight:bold">&gt;</span> <span style="color:#ff7b72;font-weight:bold">*</span>ptr) {
</span></span><span style="display:flex;"><span>  <span style="color:#8b949e;font-style:italic">//私有函数：在以ptr为根的二叉搜索树中递归搜索结点x
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>    <span style="color:#ff7b72">if</span> ( ptr <span style="color:#ff7b72;font-weight:bold">==</span> NULL ) <span style="color:#ff7b72">return</span> NULL;      <span style="color:#8b949e;font-style:italic">//搜索失败
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>    <span style="color:#ff7b72">else</span> <span style="color:#d2a8ff;font-weight:bold">if</span> (x <span style="color:#ff7b72;font-weight:bold">&lt;</span> ptr<span style="color:#ff7b72;font-weight:bold">-&gt;</span>data )                          <span style="color:#8b949e;font-style:italic">//在左子树搜索
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>                <span style="color:#ff7b72">return</span> Search( x, ptr<span style="color:#ff7b72;font-weight:bold">-&gt;</span>left );	
</span></span><span style="display:flex;"><span>           <span style="color:#ff7b72">else</span> <span style="color:#d2a8ff;font-weight:bold">if</span> ( x <span style="color:#ff7b72;font-weight:bold">&gt;</span> ptr<span style="color:#ff7b72;font-weight:bold">-&gt;</span>data )                  <span style="color:#8b949e;font-style:italic">//在右子树搜索
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>                        <span style="color:#ff7b72">return</span> Search( x, ptr<span style="color:#ff7b72;font-weight:bold">-&gt;</span>right );		             
</span></span><span style="display:flex;"><span>                  <span style="color:#ff7b72">else</span> <span style="color:#ff7b72">return</span> ptr;                     <span style="color:#8b949e;font-style:italic">//相等，搜索成功
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>}
</span></span></code></pre></div><p>非递归实现：</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#ff7b72">template</span> <span style="color:#ff7b72;font-weight:bold">&lt;</span><span style="color:#ff7b72">class</span> <span style="color:#f0883e;font-weight:bold">E</span>, <span style="color:#ff7b72">class</span> <span style="color:#f0883e;font-weight:bold">K</span><span style="color:#ff7b72;font-weight:bold">&gt;</span> 
</span></span><span style="display:flex;"><span>BSTNode<span style="color:#ff7b72;font-weight:bold">&lt;</span>E, K<span style="color:#ff7b72;font-weight:bold">&gt;</span> <span style="color:#ff7b72;font-weight:bold">*</span>BST<span style="color:#ff7b72;font-weight:bold">&lt;</span>E, K<span style="color:#ff7b72;font-weight:bold">&gt;</span> <span style="color:#ff7b72;font-weight:bold">::</span> Search( <span style="color:#ff7b72">const</span> K x, BSTNode<span style="color:#ff7b72;font-weight:bold">&lt;</span>E, K<span style="color:#ff7b72;font-weight:bold">&gt;</span> <span style="color:#ff7b72;font-weight:bold">*</span>ptr) <span style="color:#ff7b72">const</span> {
</span></span><span style="display:flex;"><span> <span style="color:#8b949e;font-style:italic">//二叉搜索树的迭代的搜索算法
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>    BSTNode<span style="color:#ff7b72;font-weight:bold">&lt;</span>E, K<span style="color:#ff7b72;font-weight:bold">&gt;</span> <span style="color:#ff7b72;font-weight:bold">*</span>p <span style="color:#ff7b72;font-weight:bold">=</span> ptr;        <span style="color:#8b949e;font-style:italic">//从根开始搜索
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>    <span style="color:#ff7b72">while</span> ( p <span style="color:#ff7b72;font-weight:bold">!=</span> NULL ) 		
</span></span><span style="display:flex;"><span>	 <span style="color:#ff7b72">if</span> ( x <span style="color:#ff7b72;font-weight:bold">==</span> p<span style="color:#ff7b72;font-weight:bold">-&gt;</span>data ) <span style="color:#ff7b72">return</span> p;           <span style="color:#8b949e;font-style:italic">//搜索成功
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>            <span style="color:#ff7b72">else</span> <span style="color:#d2a8ff;font-weight:bold">if</span> ( x <span style="color:#ff7b72;font-weight:bold">&lt;</span> p<span style="color:#ff7b72;font-weight:bold">-&gt;</span>data ) p <span style="color:#ff7b72;font-weight:bold">=</span> p<span style="color:#ff7b72;font-weight:bold">-&gt;</span>left;   <span style="color:#8b949e;font-style:italic">//沿左子树搜索
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>                   <span style="color:#ff7b72">else</span> p <span style="color:#ff7b72;font-weight:bold">=</span> p<span style="color:#ff7b72;font-weight:bold">-&gt;</span>right;                      <span style="color:#8b949e;font-style:italic">//沿右子树搜索
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>    <span style="color:#ff7b72">return</span> p;         <span style="color:#8b949e;font-style:italic">//搜索失败
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>}    
</span></span></code></pre></div><hr>
<h3 id="bst插入算法">
  BST插入算法
  <a class="heading-link" href="#bst%e6%8f%92%e5%85%a5%e7%ae%97%e6%b3%95">
    <i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"></i>
    <span class="sr-only">链接到标题</span>
  </a>
</h3>
<h4 id="基本思想-1">
  基本思想
  <a class="heading-link" href="#%e5%9f%ba%e6%9c%ac%e6%80%9d%e6%83%b3-1">
    <i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"></i>
    <span class="sr-only">链接到标题</span>
  </a>
</h4>
<ul>
<li>若要在二叉搜索树中插入一个新元素，<strong>首先要使用搜索算法</strong>检查该元素在树中是否存在；</li>
<li>如果搜索成功，树中已有这个元素，不再插入；</li>
<li>如果<strong>搜索不成功，则生成新元素结点</strong>，把新结点作为叶结点插入到搜索操作停止的地方。</li>
</ul>
<p>插入实际是<strong>先搜索，再插入</strong>的过程</p>
<p>代码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>TreeNode<span style="color:#ff7b72;font-weight:bold">*</span> <span style="color:#d2a8ff;font-weight:bold">insert</span>(TreeNode<span style="color:#ff7b72;font-weight:bold">*</span> node, <span style="color:#ff7b72">const</span> string<span style="color:#ff7b72;font-weight:bold">&amp;</span> key, <span style="color:#ff7b72">const</span> string<span style="color:#ff7b72;font-weight:bold">&amp;</span> value) {
</span></span><span style="display:flex;"><span>    <span style="color:#8b949e;font-style:italic">// 如果树为空，直接返回新节点作为根节点
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>    <span style="color:#ff7b72">if</span> (node <span style="color:#ff7b72;font-weight:bold">==</span> <span style="color:#ff7b72">nullptr</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#ff7b72">return</span> <span style="color:#ff7b72">new</span> TreeNode(key, value);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    TreeNode<span style="color:#ff7b72;font-weight:bold">*</span> cur <span style="color:#ff7b72;font-weight:bold">=</span> node;
</span></span><span style="display:flex;"><span>    <span style="color:#ff7b72">while</span> (cur <span style="color:#ff7b72;font-weight:bold">!=</span> <span style="color:#ff7b72">nullptr</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#8b949e;font-style:italic">// 如果键小于当前节点的键，向左子树插入
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>        <span style="color:#ff7b72">if</span> (key <span style="color:#ff7b72;font-weight:bold">&lt;</span> cur<span style="color:#ff7b72;font-weight:bold">-&gt;</span>key) {
</span></span><span style="display:flex;"><span>            <span style="color:#8b949e;font-style:italic">// 如果左子节点为空，则插入
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>            <span style="color:#ff7b72">if</span> (cur<span style="color:#ff7b72;font-weight:bold">-&gt;</span>left <span style="color:#ff7b72;font-weight:bold">==</span> <span style="color:#ff7b72">nullptr</span>) {
</span></span><span style="display:flex;"><span>                cur<span style="color:#ff7b72;font-weight:bold">-&gt;</span>left <span style="color:#ff7b72;font-weight:bold">=</span> <span style="color:#ff7b72">new</span> TreeNode(key, value);
</span></span><span style="display:flex;"><span>                <span style="color:#ff7b72">return</span> node; <span style="color:#8b949e;font-style:italic">// 返回根节点
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>            }
</span></span><span style="display:flex;"><span>            cur <span style="color:#ff7b72;font-weight:bold">=</span> cur<span style="color:#ff7b72;font-weight:bold">-&gt;</span>left; <span style="color:#8b949e;font-style:italic">// 否则继续向左子树移动
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#8b949e;font-style:italic">// 如果键大于当前节点的键，向右子树插入
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>        <span style="color:#ff7b72">else</span> <span style="color:#ff7b72">if</span> (key <span style="color:#ff7b72;font-weight:bold">&gt;</span> cur<span style="color:#ff7b72;font-weight:bold">-&gt;</span>key) {
</span></span><span style="display:flex;"><span>            <span style="color:#8b949e;font-style:italic">// 如果右子节点为空，则插入
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>            <span style="color:#ff7b72">if</span> (cur<span style="color:#ff7b72;font-weight:bold">-&gt;</span>right <span style="color:#ff7b72;font-weight:bold">==</span> <span style="color:#ff7b72">nullptr</span>) {
</span></span><span style="display:flex;"><span>                cur<span style="color:#ff7b72;font-weight:bold">-&gt;</span>right <span style="color:#ff7b72;font-weight:bold">=</span> <span style="color:#ff7b72">new</span> TreeNode(key, value);
</span></span><span style="display:flex;"><span>                <span style="color:#ff7b72">return</span> node; <span style="color:#8b949e;font-style:italic">// 返回根节点
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>            }
</span></span><span style="display:flex;"><span>            cur <span style="color:#ff7b72;font-weight:bold">=</span> cur<span style="color:#ff7b72;font-weight:bold">-&gt;</span>right; <span style="color:#8b949e;font-style:italic">// 否则继续向右子树移动
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#8b949e;font-style:italic">// 如果键相等，更新节点的值
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>        <span style="color:#ff7b72">else</span> {
</span></span><span style="display:flex;"><span>            cur<span style="color:#ff7b72;font-weight:bold">-&gt;</span>value <span style="color:#ff7b72;font-weight:bold">=</span> value;
</span></span><span style="display:flex;"><span>            <span style="color:#ff7b72">return</span> node; <span style="color:#8b949e;font-style:italic">// 返回根节点
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#ff7b72">return</span> node; <span style="color:#8b949e;font-style:italic">// 返回根节点
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>}
</span></span></code></pre></div><hr>
<h3 id="bst删除算法">
  BST删除算法
  <a class="heading-link" href="#bst%e5%88%a0%e9%99%a4%e7%ae%97%e6%b3%95">
    <i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"></i>
    <span class="sr-only">链接到标题</span>
  </a>
</h3>
<p>删除就稍微比查找与插入复杂一点，因为需要分类讨论了。</p>
<h4 id="被删除结点为叶子结点">
  被删除结点为叶子结点
  <a class="heading-link" href="#%e8%a2%ab%e5%88%a0%e9%99%a4%e7%bb%93%e7%82%b9%e4%b8%ba%e5%8f%b6%e5%ad%90%e7%bb%93%e7%82%b9">
    <i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"></i>
    <span class="sr-only">链接到标题</span>
  </a>
</h4>
<p>直接从二叉排序中删除即可，不会影响到其他结点</p>
<p><img src="https://cdn.jsdelivr.net/gh/fsj2009yx/picServer@main/202412021559902.png" alt="85d1a3e1d0508f8fbf440a31bf5e9be9"></p>
<h4 id="被删除结点d仅有一个孩子">
  被删除结点D仅有一个孩子
  <a class="heading-link" href="#%e8%a2%ab%e5%88%a0%e9%99%a4%e7%bb%93%e7%82%b9d%e4%bb%85%e6%9c%89%e4%b8%80%e4%b8%aa%e5%ad%a9%e5%ad%90">
    <i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"></i>
    <span class="sr-only">链接到标题</span>
  </a>
</h4>
<blockquote>
<ul>
<li>如果只有左孩子，没有右孩子，那么只需要把要删除结点的左孩子连接到要删除结点的父亲结点，然后删除D结点；</li>
<li>如果只有右孩子，没有左孩子，那么只要将要删除结点D的右孩子连接到要删除结点D的父亲结点，然后删除D结点。</li>
</ul>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/fsj2009yx/picServer@main/202412021559910.png" alt="6d5fd1743fbe9029165256198a624384"></p>
<p><img src="https://cdn.jsdelivr.net/gh/fsj2009yx/picServer@main/202412021559930.png" alt="2caf9806c3ab94d5f60de66b650dcce8"></p>
<h4 id="被删除结点左右孩子都在">
  被删除结点左右孩子都在
  <a class="heading-link" href="#%e8%a2%ab%e5%88%a0%e9%99%a4%e7%bb%93%e7%82%b9%e5%b7%a6%e5%8f%b3%e5%ad%a9%e5%ad%90%e9%83%bd%e5%9c%a8">
    <i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"></i>
    <span class="sr-only">链接到标题</span>
  </a>
</h4>
<p>当前节点有两个子节点，<strong>找到右子树的最小节点替代当前节点</strong></p>
<p>以图示流程帮助理解：</p>
<p>我们的目标依然是要保证<strong>删除结点8后，再次中序遍历它，仍不改变其升序的排列方式</strong>。 那么我们只有<strong>用7或者10来替换8原来的位置</strong>。</p>
<p>我们先看7来顶替位置</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/908eb1f8b3c2057ebceeadac793463a4.png" alt=""></p>
<p>我们再看10来顶替位置</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/55cae8538713f74d0ba97f69a4aaf3f4.png" alt="csdn"></p>
<p>由图得知，用<strong>7</strong>和用<strong>10</strong>顶替被删除节点的位置都是可行的</p>
<p><!-- raw HTML omitted -->即使用待删除结点下<strong>右子树的最小结点</strong>或<strong>左子树的最大结点</strong><!-- raw HTML omitted --></p>
<p><!-- raw HTML omitted -->也就是与<strong>待删除结点大小最接近的两个结点</strong><!-- raw HTML omitted --></p>
<blockquote>
<p>为遵循一般习惯，我们通常使用<strong>右子树的最小结点</strong>来顶替待删除结点</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/fsj2009yx/picServer@main/202412021600992.png" alt="097f66b2248a0017fa55c52292e691f3"></p>
<p>代码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>TreeNode<span style="color:#ff7b72;font-weight:bold">*</span> <span style="color:#d2a8ff;font-weight:bold">remove</span>(TreeNode<span style="color:#ff7b72;font-weight:bold">*</span> node, <span style="color:#ff7b72">const</span> string<span style="color:#ff7b72;font-weight:bold">&amp;</span> key) {
</span></span><span style="display:flex;"><span>    <span style="color:#ff7b72">if</span> (node <span style="color:#ff7b72;font-weight:bold">==</span> <span style="color:#ff7b72">nullptr</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#ff7b72">return</span> <span style="color:#ff7b72">nullptr</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff7b72">if</span> (key <span style="color:#ff7b72;font-weight:bold">&lt;</span> node<span style="color:#ff7b72;font-weight:bold">-&gt;</span>key) {
</span></span><span style="display:flex;"><span>        node<span style="color:#ff7b72;font-weight:bold">-&gt;</span>left <span style="color:#ff7b72;font-weight:bold">=</span> remove(node<span style="color:#ff7b72;font-weight:bold">-&gt;</span>left, key);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff7b72">else</span> <span style="color:#ff7b72">if</span> (key <span style="color:#ff7b72;font-weight:bold">&gt;</span> node<span style="color:#ff7b72;font-weight:bold">-&gt;</span>key) {
</span></span><span style="display:flex;"><span>        node<span style="color:#ff7b72;font-weight:bold">-&gt;</span>right <span style="color:#ff7b72;font-weight:bold">=</span> remove(node<span style="color:#ff7b72;font-weight:bold">-&gt;</span>right, key);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff7b72">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#8b949e;font-style:italic">// 当前节点是要删除的节点
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>        <span style="color:#ff7b72">if</span> (node<span style="color:#ff7b72;font-weight:bold">-&gt;</span>left <span style="color:#ff7b72;font-weight:bold">==</span> <span style="color:#ff7b72">nullptr</span>) {
</span></span><span style="display:flex;"><span>            TreeNode<span style="color:#ff7b72;font-weight:bold">*</span> temp <span style="color:#ff7b72;font-weight:bold">=</span> node<span style="color:#ff7b72;font-weight:bold">-&gt;</span>right;
</span></span><span style="display:flex;"><span>            <span style="color:#ff7b72">delete</span> node;
</span></span><span style="display:flex;"><span>            <span style="color:#ff7b72">return</span> temp;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#ff7b72">else</span> <span style="color:#ff7b72">if</span> (node<span style="color:#ff7b72;font-weight:bold">-&gt;</span>right <span style="color:#ff7b72;font-weight:bold">==</span> <span style="color:#ff7b72">nullptr</span>) {
</span></span><span style="display:flex;"><span>            TreeNode<span style="color:#ff7b72;font-weight:bold">*</span> temp <span style="color:#ff7b72;font-weight:bold">=</span> node<span style="color:#ff7b72;font-weight:bold">-&gt;</span>left;
</span></span><span style="display:flex;"><span>            <span style="color:#ff7b72">delete</span> node;
</span></span><span style="display:flex;"><span>            <span style="color:#ff7b72">return</span> temp;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#8b949e;font-style:italic">// 当前节点有两个子节点，找到右子树的最小节点替代当前节点
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>        TreeNode<span style="color:#ff7b72;font-weight:bold">*</span> temp <span style="color:#ff7b72;font-weight:bold">=</span> minNode(node<span style="color:#ff7b72;font-weight:bold">-&gt;</span>right);
</span></span><span style="display:flex;"><span>        node<span style="color:#ff7b72;font-weight:bold">-&gt;</span>key <span style="color:#ff7b72;font-weight:bold">=</span> temp<span style="color:#ff7b72;font-weight:bold">-&gt;</span>key;
</span></span><span style="display:flex;"><span>        node<span style="color:#ff7b72;font-weight:bold">-&gt;</span>value <span style="color:#ff7b72;font-weight:bold">=</span> temp<span style="color:#ff7b72;font-weight:bold">-&gt;</span>value;
</span></span><span style="display:flex;"><span>        node<span style="color:#ff7b72;font-weight:bold">-&gt;</span>right <span style="color:#ff7b72;font-weight:bold">=</span> remove(node<span style="color:#ff7b72;font-weight:bold">-&gt;</span>right, temp<span style="color:#ff7b72;font-weight:bold">-&gt;</span>key);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff7b72">return</span> node;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<h3 id="bst性能分析">
  BST性能分析
  <a class="heading-link" href="#bst%e6%80%a7%e8%83%bd%e5%88%86%e6%9e%90">
    <i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"></i>
    <span class="sr-only">链接到标题</span>
  </a>
</h3>
<p>BST的性能与<strong>二叉搜索树的形态</strong>直接相关</p>
<p>因此我们要尽量控制<strong>对节点元素的插入顺序</strong>，避免其退化成单支树</p>
<p><img src="https://cdn.jsdelivr.net/gh/fsj2009yx/picServer@main/202412021602807.png" alt="3b5ae225c4d02cda7712eb7950f29a36"></p>
<p><strong>ASL的计算：</strong></p>
<p>ASL的计算公式如下：</p>
<ul>
<li>成功的平均搜索长度($ASL_{succ}$) = $\frac{1}{n}\sum_{i=1}^{n} (树的深度)*(当前深度下节点的个数)$</li>
<li>失败的平均搜索长度($ASL_{unsucc}$) = $\frac{1}{n+1}\sum_{i=1}^{n+1} (搜索失败节点的深度)*(当前深度下搜索失败节点的个数)$</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/fsj2009yx/picServer@main/202412021609371.png" alt="999cfea8da70d88d36252bd3578f729b"></p>
<p>由图，以搜索失败的<strong>ASL</strong>来解释，由于<strong>搜索失败只会在子节点出现</strong>：</p>
<ul>
<li>第三层的失败节点个数为3</li>
<li>第四层的失败节点为4</li>
</ul>
<p>由公式得5×3+6×4，除以（n+1），得到搜索失败的平均搜索长度。</p>
<hr>
<h2 id="平衡二叉搜索树avl树">
  平衡二叉搜索树（AVL树）
  <a class="heading-link" href="#%e5%b9%b3%e8%a1%a1%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91avl%e6%a0%91">
    <i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"></i>
    <span class="sr-only">链接到标题</span>
  </a>
</h2>
<p>由于二叉搜索树BST的性能受<strong>输入顺序</strong>影响，当输入顺序不好时会让BST<strong>退化</strong></p>
<p>而<strong>AVL树</strong>在每一次插入后都会调整树的结构，以达到<strong>高度平衡化</strong></p>
<hr>
<h3 id="avl树的性质">
  AVL树的性质
  <a class="heading-link" href="#avl%e6%a0%91%e7%9a%84%e6%80%a7%e8%b4%a8">
    <i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"></i>
    <span class="sr-only">链接到标题</span>
  </a>
</h3>
<p>当我们向二叉搜索树中插入新节点时，如果能用某种方法时刻保证树中每个节点的<strong>左右子树高度之差</strong>不超过1，就可以降低整棵树的高度，保证每条分支的平衡</p>
<p>AVL树的性质如下：</p>
<ul>
<li>AVL树可以是空树</li>
<li>一颗AVL树的左右子树都是AVL树</li>
<li>一颗AVL树的左右子树高度差不超过1</li>
</ul>
<hr>
<h3 id="结点的平衡因子bf">
  结点的平衡因子（bf）
  <a class="heading-link" href="#%e7%bb%93%e7%82%b9%e7%9a%84%e5%b9%b3%e8%a1%a1%e5%9b%a0%e5%ad%90bf">
    <i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"></i>
    <span class="sr-only">链接到标题</span>
  </a>
</h3>
<p>AVL树的左右子树高度差不能超过1，但是如何便捷的去检测该性质是否被打破呢？</p>
<p>我们可以在节点中定义一个<strong>平衡因子</strong>：如果<strong>左子树比右子树高一层</strong>，那么<strong>平衡因子就为-1</strong>；如果左右子树一样高，平衡因子就为0；如果<strong>右子树比左子树高一层</strong>，那么<strong>平衡因子就为1</strong>，这三种情况下AVL树的性质都没有被打破。</p>
<p>按照这个规则，<strong>如果平衡因子为-2、2或其他值，则说明左右子树已经失衡，性质被打破</strong>。</p>
<p>在调整失衡的AVL树时，我们需要频繁的访问父节点，所以<strong>在AVL树中我们需要使用三叉链</strong>，因此AVL树的节点<strong>除了包含左右子节点的指针，还需要一个指向父节点的指针。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/fsj2009yx/picServer@main/202412021642620.png" alt="1dbe4f9c674451af3ec1b184b489a037"></p>
<hr>
<h3 id="平衡化旋转">
  平衡化旋转
  <a class="heading-link" href="#%e5%b9%b3%e8%a1%a1%e5%8c%96%e6%97%8b%e8%bd%ac">
    <i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"></i>
    <span class="sr-only">链接到标题</span>
  </a>
</h3>
<p>平衡化旋转有两类：</p>
<ul>
<li>
<p>单旋转（左单旋和右单旋）</p>
</li>
<li>
<p>双旋转（先左后右双旋和先右后左双旋）</p>
</li>
</ul>
<p>如果这<strong>三个结点处于一条直线（不平衡情况为LL型和RR型</strong>）上，则采用<strong>单旋转</strong>进行平衡化。</p>
<p>如果这<strong>三个结点处于一条折线（不平衡情况为LR型和RL型）<strong>上，则采用</strong>双旋转</strong>进行平衡化。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fsj2009yx/picServer@main/202412021647065.png" alt="eb01302d6390a3349f91c0f4d70132c2"></p>
<p><img src="https://cdn.jsdelivr.net/gh/fsj2009yx/picServer@main/202412021647011.png" alt="8d4ccea28a6fff2cc2825fa8f2aa0154"></p>
<hr>
<h4 id="单旋转">
  单旋转
  <a class="heading-link" href="#%e5%8d%95%e6%97%8b%e8%bd%ac">
    <i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"></i>
    <span class="sr-only">链接到标题</span>
  </a>
</h4>
<p>以**LL型（右单旋转）**为例：</p>
<p><strong>操作步骤：</strong></p>
<ul>
<li>选择根节点的左子节点作为新的根节点。</li>
<li>根节点变为新的根节点的右子节点。</li>
<li>原来左子节点的右子树变为新根节点的左子树。</li>
</ul>
<p>图示如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/fsj2009yx/picServer@main/202412021652183.png" alt="7645fbf8fb73821f5f4a5b6a69825a6c"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/e865c3eb1ff27e6bf59df3cc746e3b93.gif" alt="csdn"></p>
<p>右单旋转的示例代码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#ff7b72">template</span> <span style="color:#ff7b72;font-weight:bold">&lt;</span><span style="color:#ff7b72">class</span> <span style="color:#f0883e;font-weight:bold">E</span>, <span style="color:#ff7b72">class</span> <span style="color:#f0883e;font-weight:bold">K</span><span style="color:#ff7b72;font-weight:bold">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#ff7b72">void</span> AVLTree<span style="color:#ff7b72;font-weight:bold">&lt;</span>E, K<span style="color:#ff7b72;font-weight:bold">&gt;</span> <span style="color:#ff7b72;font-weight:bold">::</span>
</span></span><span style="display:flex;"><span>RotateR ( AVLNode<span style="color:#ff7b72;font-weight:bold">&lt;</span>E, K<span style="color:#ff7b72;font-weight:bold">&gt;</span> <span style="color:#ff7b72;font-weight:bold">*&amp;</span> ptr ) {
</span></span><span style="display:flex;"><span> <span style="color:#8b949e;font-style:italic">//对以ptr为根的AVL树做右单旋转，旋转后新根在ptr       
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>     AVLNode<span style="color:#ff7b72;font-weight:bold">&lt;</span>E, K<span style="color:#ff7b72;font-weight:bold">&gt;</span> <span style="color:#ff7b72;font-weight:bold">*</span>subR <span style="color:#ff7b72;font-weight:bold">=</span> ptr;   <span style="color:#8b949e;font-style:italic">//保存要右旋的根结点
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>     ptr <span style="color:#ff7b72;font-weight:bold">=</span> subR<span style="color:#ff7b72;font-weight:bold">-&gt;</span>left;                         <span style="color:#8b949e;font-style:italic">//ptr指向原根的左子女
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>     subR<span style="color:#ff7b72;font-weight:bold">-&gt;</span>left <span style="color:#ff7b72;font-weight:bold">=</span> ptr<span style="color:#ff7b72;font-weight:bold">-&gt;</span>right;           <span style="color:#8b949e;font-style:italic">//ptr成为新根前卸掉右边负载
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>     ptr<span style="color:#ff7b72;font-weight:bold">-&gt;</span>right <span style="color:#ff7b72;font-weight:bold">=</span> subR; <span style="color:#8b949e;font-style:italic">//右单旋转：ptr成为新根，原根成为ptr的右子女
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>     ptr<span style="color:#ff7b72;font-weight:bold">-&gt;</span>bf <span style="color:#ff7b72;font-weight:bold">=</span> subR<span style="color:#ff7b72;font-weight:bold">-&gt;</span>bf <span style="color:#ff7b72;font-weight:bold">=</span> <span style="color:#a5d6ff">0</span>;
</span></span><span style="display:flex;"><span>}                         
</span></span></code></pre></div><p>**RR型（左单旋转）**的算法与LL型同理，不多解释</p>
<hr>
<h4 id="双旋转">
  双旋转
  <a class="heading-link" href="#%e5%8f%8c%e6%97%8b%e8%bd%ac">
    <i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"></i>
    <span class="sr-only">链接到标题</span>
  </a>
</h4>
<p>以**LR型（先左后右双旋转）**为例：</p>
<p>左右旋操作用于解决<strong>左子树的右子树过高</strong>的问题（称为<strong>左右情况</strong>）。这是一个复合旋转，先进行左旋，再进行右旋。</p>
<p><strong>操作步骤：</strong></p>
<ul>
<li>首先对左子节点进行左旋（使得左子节点的右子树下降）。</li>
<li>然后对当前根节点进行右旋。</li>
</ul>
<p>图示如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/fsj2009yx/picServer@main/202412021656323.png" alt="2fce877ac0d547e2bd6aa757d80eb003"></p>
<p><img src="https://cdn.jsdelivr.net/gh/fsj2009yx/picServer@main/202412021657788.png" alt="46a7040eb171607500eaa17adab54da3"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/5e8cefa5dfb0af8fed42599c2a42df44.gif" alt="csdn"></p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#ff7b72">void</span> <span style="color:#d2a8ff;font-weight:bold">RotateLR</span>(Node <span style="color:#ff7b72;font-weight:bold">*</span>parent)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    Node <span style="color:#ff7b72;font-weight:bold">*</span>subL <span style="color:#ff7b72;font-weight:bold">=</span> parent<span style="color:#ff7b72;font-weight:bold">-&gt;</span>_left;
</span></span><span style="display:flex;"><span>    Node <span style="color:#ff7b72;font-weight:bold">*</span>subLR <span style="color:#ff7b72;font-weight:bold">=</span> subL<span style="color:#ff7b72;font-weight:bold">-&gt;</span>_right;
</span></span><span style="display:flex;"><span>    <span style="color:#ff7b72">int</span> bf <span style="color:#ff7b72;font-weight:bold">=</span> subLR<span style="color:#ff7b72;font-weight:bold">-&gt;</span>_bf; <span style="color:#8b949e;font-style:italic">//记录插入节点后subLR的平衡因子
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span> 
</span></span><span style="display:flex;"><span>    RotateLeft(subL); <span style="color:#8b949e;font-style:italic">//先左单旋
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>    RotateRight(parent); <span style="color:#8b949e;font-style:italic">//再右单旋
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span> 
</span></span><span style="display:flex;"><span>    <span style="color:#8b949e;font-style:italic">//更新平衡因子
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>    <span style="color:#8b949e;font-style:italic">//通过前面记录的平衡因子判断更新的情况
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>    <span style="color:#ff7b72">if</span> (bf <span style="color:#ff7b72;font-weight:bold">==</span> <span style="color:#a5d6ff">0</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        parent<span style="color:#ff7b72;font-weight:bold">-&gt;</span>_bf <span style="color:#ff7b72;font-weight:bold">=</span> subL<span style="color:#ff7b72;font-weight:bold">-&gt;</span>_bf <span style="color:#ff7b72;font-weight:bold">=</span> subLR<span style="color:#ff7b72;font-weight:bold">-&gt;</span>_bf <span style="color:#ff7b72;font-weight:bold">=</span> <span style="color:#a5d6ff">0</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff7b72">else</span> <span style="color:#ff7b72">if</span> (bf <span style="color:#ff7b72;font-weight:bold">==</span> <span style="color:#a5d6ff">1</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        subL<span style="color:#ff7b72;font-weight:bold">-&gt;</span>_bf <span style="color:#ff7b72;font-weight:bold">=</span> <span style="color:#ff7b72;font-weight:bold">-</span><span style="color:#a5d6ff">1</span>;
</span></span><span style="display:flex;"><span>        parent<span style="color:#ff7b72;font-weight:bold">-&gt;</span>_bf <span style="color:#ff7b72;font-weight:bold">=</span> subLR<span style="color:#ff7b72;font-weight:bold">-&gt;</span>_bf <span style="color:#ff7b72;font-weight:bold">=</span> <span style="color:#a5d6ff">0</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff7b72">else</span> <span style="color:#ff7b72">if</span> (bf <span style="color:#ff7b72;font-weight:bold">==</span> <span style="color:#ff7b72;font-weight:bold">-</span><span style="color:#a5d6ff">1</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        parent<span style="color:#ff7b72;font-weight:bold">-&gt;</span>_bf <span style="color:#ff7b72;font-weight:bold">=</span> <span style="color:#a5d6ff">1</span>;
</span></span><span style="display:flex;"><span>        subL<span style="color:#ff7b72;font-weight:bold">-&gt;</span>_bf <span style="color:#ff7b72;font-weight:bold">=</span> subLR<span style="color:#ff7b72;font-weight:bold">-&gt;</span>_bf <span style="color:#ff7b72;font-weight:bold">=</span> <span style="color:#a5d6ff">0</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff7b72">else</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        assert(false);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<h3 id="avl的插入算法">
  AVL的插入算法
  <a class="heading-link" href="#avl%e7%9a%84%e6%8f%92%e5%85%a5%e7%ae%97%e6%b3%95">
    <i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"></i>
    <span class="sr-only">链接到标题</span>
  </a>
</h3>
<p><img src="https://cdn.jsdelivr.net/gh/fsj2009yx/picServer@main/202412021700653.png" alt="6edda0e1518fc745dd87dfa6c1b2a6f2"></p>
<p><img src="https://cdn.jsdelivr.net/gh/fsj2009yx/picServer@main/202412021711474.png" alt="c10d5d37fcff38692bc968a5c529d2d8"></p>
<hr>
<h3 id="avl树的删除算法">
  AVL树的删除算法
  <a class="heading-link" href="#avl%e6%a0%91%e7%9a%84%e5%88%a0%e9%99%a4%e7%ae%97%e6%b3%95">
    <i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"></i>
    <span class="sr-only">链接到标题</span>
  </a>
</h3>
<p>AVL树的删除与BST类似，也是<strong>先搜索再删除</strong></p>
<p>只是当删除完结点后可能破坏原本的平衡，此时还需做<strong>平衡化处理</strong></p>
<hr>
<h2 id="m路搜索树">
  m路搜索树
  <a class="heading-link" href="#m%e8%b7%af%e6%90%9c%e7%b4%a2%e6%a0%91">
    <i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"></i>
    <span class="sr-only">链接到标题</span>
  </a>
</h2>
<p>二叉搜索树适合于组织在内存中的较小的索引（或目录）。对于存放在外存中的较大的文件系统</p>
<p>对于存放在外存中的较大的文件系统，用二叉搜索树来组织索引就不太合适。若以结点作为内外存交换的单位，则在搜索过程中需对外存进行**O(log2n)**次访问，显然很费时</p>
<p>于是我们引入多路搜索树：</p>
<ul>
<li>多路搜索树既可能是静态索引结构，也可能是动态索引结构</li>
<li>现在所讨论的 <em>m</em> 路搜索树多为可以动态调整的多路搜索树，即树的结构随数据的增删及时调整，以保持最佳的搜索效率</li>
</ul>
<hr>
<h3 id="m路搜索树基本概念">
  m路搜索树基本概念
  <a class="heading-link" href="#m%e8%b7%af%e6%90%9c%e7%b4%a2%e6%a0%91%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5">
    <i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"></i>
    <span class="sr-only">链接到标题</span>
  </a>
</h3>
<h4 id="m路搜索树的定义">
  m路搜索树的定义
  <a class="heading-link" href="#m%e8%b7%af%e6%90%9c%e7%b4%a2%e6%a0%91%e7%9a%84%e5%ae%9a%e4%b9%89">
    <i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"></i>
    <span class="sr-only">链接到标题</span>
  </a>
</h4>
<p>m 叉搜索树（m-way search tree）可以是一棵空树，如果非空，它必须满足以下特征：</p>
<ul>
<li>在相应的扩充搜索树中（用外部节点替换零指针），每个内部节点最多可以有m 个子女及1～m-1个元素（外部节点不含元素和子女）。</li>
<li>每个含p个元素的节点，有p+1个子女。</li>
<li>考察含p 个元素的任意节点。设k1 , …, kp 是这些元素的关键值。这些元素升序排列，即有k1 &lt; k2 &lt; . . . &lt;kp。设c0 , c1 , …, cp 是节点的p+1个孩子。以c0</li>
<li>根的子树中的元素关键值小于k1，而以cp 为根的子树中的元素关键值大于kp，并且以ci 为根的子树中的元素关键值会大于ki 而小于ki+1，其中1≤i≤p。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/fsj2009yx/picServer@main/202412022038103.png" alt="a5702cbb25c3ecfa75ba8d1bc2d05d9c"></p>
<p>m路搜索树的示例如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/fsj2009yx/picServer@main/202412022033470.png" alt="a98c761ff5288d2c1919d5c8248b1338"></p>
<h4 id="m路搜索树的性质">
  m路搜索树的性质
  <a class="heading-link" href="#m%e8%b7%af%e6%90%9c%e7%b4%a2%e6%a0%91%e7%9a%84%e6%80%a7%e8%b4%a8">
    <i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"></i>
    <span class="sr-only">链接到标题</span>
  </a>
</h4>
<p>由于高度为h的m叉搜索树中元素的个数在$h$到$m^{h} - 1$之间，所以一棵n元素的m叉搜索树的高度在$\log_m(n+1)$到$n$之间。</p>
<hr>
<h3 id="m路搜索树的搜索算法">
  m路搜索树的搜索算法
  <a class="heading-link" href="#m%e8%b7%af%e6%90%9c%e7%b4%a2%e6%a0%91%e7%9a%84%e6%90%9c%e7%b4%a2%e7%ae%97%e6%b3%95">
    <i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"></i>
    <span class="sr-only">链接到标题</span>
  </a>
</h3>
<ul>
<li>在 <em>m</em> 路搜索树上的搜索过程是一个<strong>在结点内搜索</strong>和<strong>自根结点开始循某一条路径向下一层结点搜索</strong>的交替的过程。</li>
<li>结点内的搜索一般采用顺序搜索，当<em>m</em>较大时，可采用折半搜索。</li>
</ul>
<p>搜索算法的基本思路如下：</p>
<ol>
<li><strong>开始于根节点</strong>：</li>
</ol>
<ul>
<li>搜索从树的根节点开始进行。</li>
</ul>
<ol start="2">
<li><strong>逐层比较</strong>：</li>
</ol>
<ul>
<li>在每个节点，首先检查节点的关键字（存储的值）。</li>
<li>比较目标值与当前节点的所有关键字。</li>
</ul>
<ol start="3">
<li><strong>选择子节点</strong>：</li>
</ol>
<ul>
<li>如果目标值等于某个关键字，搜索结束，找到目标值。</li>
<li>如果目标值小于当前节点的最小关键字，进入第一个子树。</li>
<li>如果目标值介于两个关键字之间，进入相应的子树（例如，第 $i$ 个关键字和第 $i+1$ 个关键字之间）。</li>
<li>如果目标值大于某个关键字，选择右边的子树。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/fsj2009yx/picServer@main/202412022047077.png" alt="e145477b306987b5197013a4d30b348d"></p>
<p>代码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#ff7b72">template</span> <span style="color:#ff7b72;font-weight:bold">&lt;</span><span style="color:#ff7b72">class</span> <span style="color:#f0883e;font-weight:bold">T</span><span style="color:#ff7b72;font-weight:bold">&gt;</span> 
</span></span><span style="display:flex;"><span>Triple<span style="color:#ff7b72;font-weight:bold">&lt;</span>T<span style="color:#ff7b72;font-weight:bold">&gt;</span>  Mtree<span style="color:#ff7b72;font-weight:bold">&lt;</span>T<span style="color:#ff7b72;font-weight:bold">&gt;</span> <span style="color:#ff7b72;font-weight:bold">::</span> Search ( <span style="color:#ff7b72">const</span> T<span style="color:#ff7b72;font-weight:bold">&amp;</span> x ) {
</span></span><span style="display:flex;"><span> <span style="color:#8b949e;font-style:italic">//用关键码x搜索驻留在磁盘上的m路搜索树，函数返回类型为三元组（r, i, tag）
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>    Triple result;               <span style="color:#8b949e;font-style:italic">//记录搜索结果三元组
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>    GetNode ( root );        <span style="color:#8b949e;font-style:italic">//从磁盘读入根结点（内外存数据交换，非常耗时）
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>    MtreeNode <span style="color:#ff7b72;font-weight:bold">&lt;</span>T<span style="color:#ff7b72;font-weight:bold">&gt;</span> <span style="color:#ff7b72;font-weight:bold">*</span>p <span style="color:#ff7b72;font-weight:bold">=</span> root, <span style="color:#ff7b72;font-weight:bold">*</span>q <span style="color:#ff7b72;font-weight:bold">=</span> NULL;  <span style="color:#8b949e;font-style:italic">//q是p的父结点指针
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>    <span style="color:#ff7b72">while</span> ( p <span style="color:#ff7b72;font-weight:bold">!=</span> NULL ) {       <span style="color:#8b949e;font-style:italic">//从根开始检测
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>         <span style="color:#ff7b72">int</span> i <span style="color:#ff7b72;font-weight:bold">=</span> <span style="color:#a5d6ff">0</span>;  p<span style="color:#ff7b72;font-weight:bold">-&gt;</span>key[(p<span style="color:#ff7b72;font-weight:bold">-&gt;</span>n)<span style="color:#ff7b72;font-weight:bold">+</span><span style="color:#a5d6ff">1</span>] <span style="color:#ff7b72;font-weight:bold">=</span> MaxValue;   <span style="color:#8b949e;font-style:italic">//监视哨
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>         <span style="color:#ff7b72">while</span> ( p<span style="color:#ff7b72;font-weight:bold">-&gt;</span>key[i<span style="color:#ff7b72;font-weight:bold">+</span><span style="color:#a5d6ff">1</span>] <span style="color:#ff7b72;font-weight:bold">&lt;</span> x ) i<span style="color:#ff7b72;font-weight:bold">++</span>;    <span style="color:#8b949e;font-style:italic">//结点内顺序搜索
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>         <span style="color:#ff7b72">if</span> ( p<span style="color:#ff7b72;font-weight:bold">-&gt;</span>key[i<span style="color:#ff7b72;font-weight:bold">+</span><span style="color:#a5d6ff">1</span>] <span style="color:#ff7b72;font-weight:bold">==</span> x ) {           <span style="color:#8b949e;font-style:italic">//搜索成功
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span> 	   result.r <span style="color:#ff7b72;font-weight:bold">=</span> p;  result.i <span style="color:#ff7b72;font-weight:bold">=</span>  i<span style="color:#ff7b72;font-weight:bold">+</span><span style="color:#a5d6ff">1</span>;  result.tag <span style="color:#ff7b72;font-weight:bold">=</span> <span style="color:#a5d6ff">0</span>;
</span></span><span style="display:flex;"><span>	   <span style="color:#ff7b72">return</span> result;
</span></span><span style="display:flex;"><span>         }  
</span></span><span style="display:flex;"><span>          <span style="color:#8b949e;font-style:italic">//本结点无x，q记下本结点
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>          q <span style="color:#ff7b72;font-weight:bold">=</span> p;   p <span style="color:#ff7b72;font-weight:bold">=</span> p<span style="color:#ff7b72;font-weight:bold">-&gt;</span>ptr[i];    <span style="color:#8b949e;font-style:italic">// p向下一层结点搜索
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>          GetNode (p);                <span style="color:#8b949e;font-style:italic">//从磁盘上读入该结点（内外存数据交换，非常耗时）
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>     }
</span></span><span style="display:flex;"><span>     result.r <span style="color:#ff7b72;font-weight:bold">=</span> q;  result.i <span style="color:#ff7b72;font-weight:bold">=</span> i;  result.tag <span style="color:#ff7b72;font-weight:bold">=</span> <span style="color:#a5d6ff">1</span>; <span style="color:#8b949e;font-style:italic">//x可能落入q结点的区间[ki, ki+1]
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>     <span style="color:#ff7b72">return</span> result;         <span style="color:#8b949e;font-style:italic">//搜索失败，返回插入位置
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>}      
</span></span></code></pre></div><hr>
<h3 id="m路搜索树的搜索性能">
  <em>m</em>路搜索树的搜索性能
  <a class="heading-link" href="#m%e8%b7%af%e6%90%9c%e7%b4%a2%e6%a0%91%e7%9a%84%e6%90%9c%e7%b4%a2%e6%80%a7%e8%83%bd">
    <i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"></i>
    <span class="sr-only">链接到标题</span>
  </a>
</h3>
<p><img src="https://cdn.jsdelivr.net/gh/fsj2009yx/picServer@main/202412022049275.png" alt="90adbe397a2a27b905bb2c514ae85cc7"></p>
<hr>
<h2 id="b-树">
  B-树
  <a class="heading-link" href="#b-%e6%a0%91">
    <i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"></i>
    <span class="sr-only">链接到标题</span>
  </a>
</h2>
<p>**m树B树（B-Tree of order m）**是一棵m叉搜索树，如果B树非空，那么相应的扩充树满足以下特征：</p>
<ul>
<li><strong>根节点至少有两个孩子</strong></li>
<li>除了根节点以外，<strong>所有内部节点至少有[m/2]个孩子</strong></li>
<li><strong>所有外部节点位于同一层上</strong>，叶节点不包含任何关键字信息</li>
<li>每个节点<strong>至多有m个孩子</strong></li>
<li>有k个孩子的非叶节点恰好包含k-1个关键字</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/fsj2009yx/picServer@main/202412022059383.png" alt="379189ec350c3d8b43a9d813deb034ea"></p>
<p>一棵B 树是平衡的 <em>m</em> 路搜索树，但一棵平衡的 <em>m</em> 路搜索树不一定是B 树。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fsj2009yx/picServer@main/202412022100058.png" alt="9edd33a069cab7fc5741fe7ae6546a6d"></p>

      </div>


      <footer>
        


        <div id="disqus_thread"></div>
<script>
  window.disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "yourdiscussshortname" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
    
    document.addEventListener('themeChanged', function (e) { 
        if (document.readyState == 'complete') {
          DISQUS.reset({ reload: true, config: disqus_config });
        }
    });
</script>
        
        
        
        
        
        
      </footer>
    </article>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css"
    integrity="sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0" crossorigin="anonymous">
  
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js"
    integrity="sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4" crossorigin="anonymous"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js"
    integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"
    onload="renderMathInElement(document.body,
      {
        delimiters: [
          {left: '$$', right: '$$', display:true},
          {left: '$', right: '$', display:false},
          {left: '\\(', right: '\\)', display: false},
          {left: '\\[', right: '\\]', display: true}
        ]
      }
    );"></script>
  </section>

    </div>

    <footer class="footer">
  <section class="container">
    ©
    
      2019 -
    
    2024
     fsj2009yx 
    ·
    
    技术支持 <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> & <a href="https://github.com/luizdepra/hugo-coder/" target="_blank" rel="noopener">Coder</a>.
    
  </section>
</footer>

  </main>

  

  
  
  <script src="/js/coder.js"></script>
  

  

  


  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  
</body>

</html>
