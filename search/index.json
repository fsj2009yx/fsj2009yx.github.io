[{"content":"汇编指令\rmov 和 add 指令\r转移指令 jmp\rJMP 指令是汇编语言中的 无条件转移指令，用于将程序的执行流程跳转到指定的目标地址（代码位置）。当 JMP 指令被执行时，CPU 会将目标地址加载到 指令指针寄存器（IP/EIP/RIP） 中，从而改变程序的执行路径。\n下面是 jmp 指令的用法：\njmp 指令用于同时修改 CS 和 IP 的内容\n语法：jmp 段地址:偏移地址\njmp 2AE3:3 jmp 3:0B16 功能：用指令给出的段地址修改 CS, 偏移地址修改 IP\n仅修改 IP 的内容\n语法：jmp 某一合法寄存器 jmp ax（类似于 mov IP, ax） jmp bx 功能：直接跳转到 CS:某一寄存器 指定的地址 举例如下：\n汇编语言程序设计\r首先给出一段完整可执行的汇编语言程序：\n1 2 3 4 5 6 7 8 9 10 assume cs:codesg codesg segment mov ax,0123H mov bx,0456H add ax,bx add ax,ax mov ax,4c00h int 21h codesg ends end 该代码的部分：\n伪指令：编译器执行的指令，没有对应机器码 1 2 3 4 5 6 assume cs:codesg codesg segment codesg ends end 汇编指令：编译为机器码的指令 1 2 3 4 5 6 mov ax,0123H mov bx,0456H add ax,bx add ax,ax mov ax,4c00h int 21h 三种伪指令\r汇编语言代码示例\r编写一个计算 2^3 的代码：\n1 2 3 4 5 6 7 8 9 10 assume cs:asc abc segment mov ax,2 add ax,ax add ax,ax mov ax,4c00h int 21h abc ends end 代码解释：\n伪指令\nassume cs:asc：指令告诉汇编器当前代码段使用的段寄存器是 CS，且段名为 asc; assume 声明仅用来表明段寄存器的逻辑关联，方便汇编器生成正确的代码。 abc segment：声明一个名为 abc 的代码段。 代码段\n一次 mov 和两次 add 实现了 2^3 的计算 程序终止\nmov ax,4c00h：用于将 4C00h 加载到寄存器 AX，该值是 DOS 系统调用的 int 21h 的功能号，用于程序终止 int 21h调用中断服务例程，执行功能号 4Ch [\u0026hellip;]和(\u0026hellip;)的语法规定\r在汇编语言中，方括号通常用于表示内存地址的访问。\n语法：\n1 2 MOV AX, [1234h] ; 将内存地址 1234h 处的值加载到 AX 寄存器 MOV [BX], AL ; 将 AL 的值存储到由 BX 指定的内存地址 在某些汇编器（如 AT\u0026amp;T 语法）中，圆括号用于内存操作的间接寻址，特别是在 x86 AT\u0026amp;T 汇编语法中。\n圆括号(\u0026hellip;)不属于汇编语言语法，只是表达汇编指令的一个助记符，它表示一个内存单元或者寄存器中的内容\n区分有无[ ]：\n有[]时：MOV AX, [BX] 表示将 BX 寄存器中存储的**地址位置的值（即内存中的数据）**加载到 AX 寄存器中 无[]时：直接使用寄存器的值。比如，MOV AX, BX 代表将寄存器 BX 的值复制到寄存器 AX 中 可以用 C++ 语法来类比理解汇编语言中寄存器有无方括号的区别。\n无方括号：类似于直接使用变量的值。\n1 2 cpp复制编辑int a = 5; int b = 10; 在汇编中，相当于 MOV AX, BX，直接将 BX 寄存器的值赋给 AX 寄存器。\n有方括号：类似于访问指针所指向的内存中的数据。\n1 2 3 int a = 5; int* ptr = \u0026amp;a; // 指针 ptr 指向 a int b = *ptr; // 通过指针访问 a 的值 在汇编中，相当于 MOV AX, [BX]，假设 BX 存储的是某个内存地址，那么 [BX] 表示访问该内存地址上的数据。\nLoop指令\r语法：loop 标号\n功能：实现循环（计数型循环）\nCPU执行Loop指令的操作：\n(cx)=(cx)-1; 判断cx中的值： 不为零则转至标号处执行程序 如果为零则向下执行 示例代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 assume cs:code ; 告诉汇编器，代码段寄存器cs指向名为\u0026#39;code\u0026#39;的段 code segment ; 定义一个代码段，命名为\u0026#39;code\u0026#39; mov ax, 2 ; 将立即数2加载到AX寄存器中 mov cx, 11 ; 将立即数11加载到CX寄存器中，作为循环计数器 s: ; 标签\u0026#39;s\u0026#39;，标记循环开始的位置 add ax, ax ; 将AX寄存器中的值加上自身（即乘以2） loop s ; CX寄存器减1，并且如果CX不为零，则跳转到标签\u0026#39;s\u0026#39; mov ax, 4c00h ; 将立即数4C00h加载到AX寄存器中，准备调用DOS中断来正常退出程序 int 21h ; 调用DOS中断21h，功能号在AH寄存器中指定（这里是4Ch，表示程序终止） code ends ; 结束代码段定义 end ; 汇编结束指令 该程序的主要功能是在AX寄存器中计算 2^11 的值（即2048），并通过DOS中断21h正常退出程序\n例：实现123*236的一个汇编程序：\n1 2 3 4 5 6 7 8 9 10 assume cs:code code segment mov ax,0 ;初始化结果为0，存在ax中 mov cx,236 s:\tadd ax,123 loop s code ends end 结合[\u0026hellip;]语法的示例代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 assume cs:code code segment mov ax,0ffffh mov ds,ax mov bx,6 mov al,[bx] mov ah,0 mov dx,0 mov cx,3 s:\tadd dx,ax loop s mov ax,4c00h int 21h code ends end mov al,[0]的异常情况和段前缀的应用\rmov al,[0]的功能本应该是将偏移地址为0的存储单元的内容赋值给寄存器al，在编译并链接后，debug程序发现该语句被翻译成了mov al ,00即将0赋值给al\n我们可以使用段前缀的方式，即在[data]前显式写上段寄存器\n语法：\n1 2 mov ax, DS:[1234h] ; 使用数据段寄存器 DS mov ax, ES:[1234h] ; 使用额外段寄存器 ES 连续内存单元的求和(ffff:0~ffff:b)\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 code segment ; 定义代码段 mov ax, 0ffffh ; 将最大16位值 (0xFFFF) 加载到 AX 寄存器 mov ds, ax ; 将 AX 中的值赋给 DS (数据段寄存器)，设置数据段为 0xFFFF mov ax, 0 ; 初始化 AX 寄存器为 0，用于中间计算 mov dx, 0 ; 初始化 DX 寄存器为 0，用于累加结果 mov cx, 12 ; 初始化循环计数器 CX 为 12，准备执行12次循环 s: ; 定义标签 s，表示循环的开始位置 mov al, [bx] ; 将 BX 寄存器指向的内存单元值加载到 AL（低8位寄存器） mov ah, 0 ; 清空 AH（高8位寄存器），确保 AX 只包含 AL 的值 add dx, ax ; 将 AX 的值累加到 DX 中 inc bx ; BX 自增 1，指向下一个内存单元 loop s ; 循环 CX 次，每次减 1，直到 CX = 0 跳出循环 mov ax, 4c00h ; 终止程序，设置 AX = 4C00h，其中 4Ch 是退出功能号 int 21h ; 调用中断 21h，终止程序 code ends ; 结束代码段 end ; 程序结束 利用段前缀实现连续内存单元的拷贝\r注：es为附加段寄存器，作为额外的数据段寄存器，通常用于字符串操作或其他需要跨段数据传输的情况\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 assume cs:code ; 假设代码段寄存器 CS 指向名为 \u0026#39;code\u0026#39; 的段 code segment ; 定义一个代码段，命名为 \u0026#39;code\u0026#39; ; 设置数据段寄存器 DS 为 0FFFFh mov ax, 0ffffh ; 将立即数 0FFFFh 加载到 AX 寄存器中 mov ds, ax ; 设置 DS 寄存器为 0FFFFh，这意味着我们将访问 0FFFF:0000 开始的内存区域 ; 设置附加段寄存器 ES 为 0020h mov ax, 0020h ; 将立即数 0020h 加载到 AX 寄存器中 mov es, ax ; 设置 ES 寄存器为 0020h，这意味着我们将写入 0020:0000 开始的内存区域 ; 初始化偏移地址 BX 和循环计数器 CX mov bx, 0 ; 将立即数 0 加载到 BX 寄存器中，作为初始偏移地址 mov cx, 12 ; 设置循环计数器 CX 为 12，表示要复制 12 个字节 s: ; 标签 \u0026#39;s\u0026#39;，标记循环开始的位置 ; 从 DS:BX 处读取一个字节的数据到 DL 寄存器 mov dl, [bx] ; 从内存地址 DS:BX 处读取一个字节的数据到 DL 寄存器 ; 将 DL 寄存器中的数据写入 ES:BX 处 mov es:[bx], dl ; 将 DL 寄存器中的数据写入内存地址 ES:BX 处 ; 增加偏移地址 BX inc bx ; BX = BX + 1 ; 循环控制 loop s ; CX 寄存器减 1，并且如果 CX 不为零，则跳转到标签 \u0026#39;s\u0026#39; ; 程序终止 mov ax, 4c00h ; 设置 AX 寄存器的值为 4C00h，准备调用 DOS 中断来正常退出程序 int 21h ; 调用 DOS 中断 21h，功能号 4Ch 表示程序终止 code ends ; 结束代码段定义 end ; 汇编结束指令 在代码段中使用数据\r实际上，在汇编语言中直接指明地址是非常危险的行为，现代操作系统都会为每个进程动态分配内存空间，如果手动修改了关键地址（如内存空间）的值，可能会导致访问冲突，甚至是程序崩溃\n此外，硬编码的地址难以理解，在后续维护中不易看出该地址数据的意义\n例题如下：\ndw关键字可以定义数据，每一个数据为一个字，占两个字节，所以存储偏移地址的寄存器bx每次要+=2 这里如果直接运行程序，代码段的起始地址在0010，而不是起始地址，如果想运行程序需要在Debug下将IP设置为10h，令CS:IP指向程序中的第一条指令，才能正常运行\n我们可以如下改进：\n利用start标号来指定程序运行的第一条指令，后面end start除了启到终止程序的作用以外，还向编译器告知程序运行的入口\n基于此，我们可以这样安排一段基本程序的框架：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 assume cs:code code segment ;定义数据 start: ;定义代码 code ends end start 在代码段中使用栈\r之前我们使用栈段和栈顶寄存器ss和sp将一段内存定义为栈，由于用到了真实的物理地址，而不是操作系统分配的内存空间，这种做法也应该抛弃\n我们可以在代码段中定义栈，示例代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 assume cs:codesg codesg segment dw 0123H, 0456H, 0789H, 0abcH, 0defH, 0fedH, 0cbaH, 0987H dw 0,0,0,0,0,0,0,0,0,0,0,0 start: mov ax, cs mov ss, ax mov sp, 30h mov bx,0 mov cx,8 s:\tpush cs:[bx] add bx,2 loop s mov bx,0 mov cx,8 s0:\tpop cs:[bx] add bx,2 loop s0 mov ax,4c00h int 21h codesg ends end start 代码解释：\n数据段定义\n前8个单元存储数据：0123H 到 0987H。 后12个单元初始化为 0，用于存储处理后的数据。 初始化寄存器\n设置栈段 (SS) 为代码段 (CS)，栈顶指针 (SP) 为 30h。 入栈过程\n从偏移 0-15H 的8个数据依次压入栈。 每次入栈后，BX 加 2 指向下一个数据。 出栈过程\n从栈中依次弹出数据，覆盖原来的偏移 0-15H 数据。 程序结束\n使用中断 int 21h 正常退出程序。 ","date":"2025-03-08T21:56:49+08:00","permalink":"https://fsj2009yx.github.io/posts/post_29432997813517/","title":"汇编指令"},{"content":"排序算法\r插入排序\r算法思路\r从第一个元素开始，该元素可以认为已经被排序 取下一个元素tem，从已排序的元素序列从后往前扫描 如果该元素大于tem，则将该元素移到下一位 重复步骤3，直到找到已排序元素中小于等于tem的元素 tem插入到该元素的后面，如果已排序所有元素都大于tem，则将tem插入到下标为0的位置 重复步骤2~5 一句话总结：每次取第$i+1$个元素，依次与前一个元素比较直到找到一个比它小的元素，插入到它的后面\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 void InsertSort(int* arr, int n) { for (int i = 0; i \u0026lt; n - 1; ++i) { //记录有序序列最后一个元素的下标 int end = i; //待插入的元素 int tem = arr[end + 1]; //单趟排 while (end \u0026gt;= 0) { //比插入的数大就向后移 if (tem \u0026lt; arr[end]) { arr[end + 1] = arr[end]; end--; } //比插入的数小，跳出循环 else { break; } } //tem放到比插入的数小的数的后面 arr[end + 1] = tem; //代码执行到此位置有两种情况: //1.待插入元素找到应插入位置（break跳出循环到此） //2.待插入元素比当前有序序列中的所有元素都小（while循环结束后到此） } } 时间复杂度：最坏情况下为O(N²)，此时待排序列为逆序，或者说接近逆序\n最好情况下为O(N)，此时待排序列为升序，或者说接近升序。\n空间复杂度：O(1)\n希尔排序\r思路：\n先选定一个小于N的gap作为第一增量，然后将所有距离为gap的元素分在同一组，并对每一组的元素进行直接插入排序。然后再取一个比第一增量小的整数作为第二增量，重复上述操作 当增量的大小减到1时，就相当于整个序列被分到一组，进行一次直接插入排序，排序完成。 一句话总结：第一次取gap=n/2，然后距离为gap的两个元素按照大小顺序决定是否交换，然后第二次取gap=gap/2，以此类推，直到gap减小到1，进行一次直接插入排序，排序完成\n如上图所示，在初始位置gap=10/2=5，将距离为5的元素分在同一组，即（8，3）、（9，5）、（1，4）、（7，6）、（2、0），每组内的两个元素比较后依照插入排序更新位置 排序结束后取gap/=2，以相同方法再次排序\n代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 //希尔排序 void ShellSort(int* arr, int n) { int gap = n; while (gap\u0026gt;1) { //每次对gap折半操作 gap = gap / 2; //单趟排序 for (int i = 0; i \u0026lt; n - gap; ++i) { int end = i; int tem = arr[end + gap]; while (end \u0026gt;= 0) { if (tem \u0026lt; arr[end]) { arr[end + gap] = arr[end]; end -= gap; } else { break; } } arr[end + gap] = tem; } } } 时间复杂度（平均）：O（N^1.3） 空间复杂度：O（1）\n选择排序\r思路： 每次从待排序列中选出一个最小值，然后放在序列的起始位置，直到全部待排数据排完即可。 实际上，我们可以一趟选出两个值，一个最大值一个最小值，然后将其放在序列开头和末尾，这样可以使选择排序的效率快一倍。\n一句话总结：每趟选出一个最小放在前面，一直排到末尾；\n我们可以一趟选出两个值，一个最大值一个最小值，然后将其放在序列开头和末尾，效率更快\n代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 //选择排序 void swap(int* a, int* b) { int tem = *a; *a = *b; *b = tem; } void SelectSort(int* arr, int n) { //保存参与单趟排序的第一个数和最后一个数的下标 int begin = 0, end = n - 1; while (begin \u0026lt; end) { //保存最大值的下标 int maxi = begin; //保存最小值的下标 int mini = begin; //找出最大值和最小值的下标 for (int i = begin; i \u0026lt;= end; ++i) { if (arr[i] \u0026lt; arr[mini]) { mini = i; } if (arr[i] \u0026gt; arr[maxi]) { maxi = i; } } //最小值放在序列开头 swap(\u0026amp;arr[mini], \u0026amp;arr[begin]); //防止最大的数在begin位置被换走 if (begin == maxi) { maxi = mini; } //最大值放在序列结尾 swap(\u0026amp;arr[maxi], \u0026amp;arr[end]); ++begin; --end; } } 时间复杂度：最坏情况：O(N^2)\n最好情况：O(N^2)\n空间复杂度：O(1)\n计数排序\r计数排序是一种非比较排序，其核心是将序列中的元素作为键存储在额外的数组空间中，而该元素的个数作为值存储在数组空间中，通过遍历该数组排序。\n计数排序的应用场景\r序列中最大值和最小值之间的差值不能过大，这主要是防止建立数组时造成内存的浪费。 序列中存在的元素是整数，因为我们使用的是该元素作为键存储在额外的数组空间中，如果不是整数，不能作为键。 代码\r创建临时数组\r我们先创建一个临时的数组tmp并且该数组的最大下标为原数组中元素的最大值（里面的元素初始化为0）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 //先遍历原数组找到最大值 int max = a[0]; for (int i = 1; i \u0026lt; n; i++) { if (max \u0026lt; a[i]) { max = a[i]; } } //动态内存开辟max+1个int空间并初始化为0用calloc int* tmp = (int)calloc(max+1, sizeof(int)); if (tmp == NULL) { perror(\u0026#34;calloc fail!\\n\u0026#34;); return; } 统计次数\r然后遍历一遍原数组，原数组中出现哪个元素就在tmp数组中与该元素数值相同的下标对应的地方进行加加操作来记录该元素出现的次数。\n1 2 3 4 5 //统计次数 for (int i = 0; i \u0026lt; n; i++) { tmp[a[i]]++; } 排序\r最后我们再进行排序，记住tmp的下标对应原数组可能出现的元素，而里面的值对应该元素出现的次数，如果为0就说明该元素在原数组不存在。遍历tmp数组，将对应的下标覆盖原数组即可完成排序。\n1 2 3 4 5 6 7 8 9 10 11 12 //排序 int j = 0; for (int i = 0; i \u0026lt; max + 1; i++)//第一层循环遍历tmp数组 { while (tmp[i]--)//对应元素出现的次数 { a[j++] = i;//tmp的下标对应的就是原数组可能出现的元素 } } //释放资源，避免内存泄漏 free(tmp); tmp = NULL; 简单版本\r完整代码如下：(c++版本)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;iterator\u0026gt; void CountSort(std::vector\u0026lt;int\u0026gt;\u0026amp; a) { // 如果数组为空，直接返回 if (a.empty()) return; // 使用std::max_element找到数组中的最大值 int max = *std::max_element(a.begin(), a.end()); // 创建一个大小为(max + 1)的数组，初始值都为0 std::vector\u0026lt;int\u0026gt; tmp(max + 1, 0); // 统计每个元素的出现次数 for (int num : a) { tmp[num]++; } // 排序阶段 int j = 0; // 遍历tmp数组，按照每个元素出现的次数重新填充原数组a for (int i = 0; i \u0026lt;= max; ++i) { // 当tmp[i]不为0时，将i填充到a数组中tmp[i]次 while (tmp[i]--) { a[j++] = i; } } } int main() { // 示例数组 std::vector\u0026lt;int\u0026gt; arr = {4, 2, 2, 8, 3, 3, 1}; // 调用计数排序函数 CountSort(arr); // 输出排序后的数组 for (int num : arr) { std::cout \u0026lt;\u0026lt; num \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } std::cout \u0026lt;\u0026lt; std::endl; return 0; } 优化\r如果我们的数据是这样的，如果还像之前那样开辟空间，会有大量的空间浪费遍历的次数增大，就存在性能的降低 如图，数据的最小值为100，而按照原代码则浪费了0-100中的数组空间，导致不必要的内存开销\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; void CountSort(std::vector\u0026lt;int\u0026gt;\u0026amp; a) { if (a.empty()) return; // 使用std::min和std::max找出数组的最小值和最大值 int min = *std::min_element(a.begin(), a.end()); int max = *std::max_element(a.begin(), a.end()); int range = max - min + 1; // 创建一个大小为range的vector，初始化为0 std::vector\u0026lt;int\u0026gt; tmp(range, 0); // 统计每个元素出现的次数 for (int num : a) { tmp[num - min]++; } // 排序阶段 int j = 0; for (int i = 0; i \u0026lt; range; ++i) { // 将tmp[i]个i+min值填充到a中 while (tmp[i]--) { a[j++] = i + min; } } } int main() { // 示例数组 std::vector\u0026lt;int\u0026gt; arr = {4, 2, 2, 8, 3, 3, 1}; // 调用计数排序函数 CountSort(arr); // 输出排序后的数组 for (int num : arr) { std::cout \u0026lt;\u0026lt; num \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } std::cout \u0026lt;\u0026lt; std::endl; return 0; } 空间复杂度：除原数组外，计数排序额外开辟了一个大小为N的临时空间，所以计数排序的空间复杂度为O(N)。 时间复杂度：遍历找最大最小值取范围的时间复杂度为O(N)，遍历原数组统计次数的时间复杂度为O(N)，而排序里面，虽有两层循环，但从思想和本质来看，它只不过是将原来的元素按顺序覆盖了原数组，其执行循环的次数任然为O(N)，所以计数排序的时间复杂度为O(N).\n归并排序\r算法思路\r归并排序算法有两个基本的操作，一个是分，也就是把原数组划分成两个子数组的过程。另一个是治，它将两个有序数组合并成一个更大的有序数组。\n将待排序的线性表不断地切分成若干个子表，直到每个子表只包含一个元素，这时，可以认为只包含一个元素的子表是有序表。 将子表两两合并，每合并一次，就会产生一个新的且更长的有序表，重复这一步骤，直到最后只剩下一个子表，这个子表就是排好序的线性表。\n一句话总结：第一次分为两组，第二次每一组又分为两组，也就是$2^2=4$组，以此类推，直到每组的元素个数为1；\n按照大小顺序逐个合并，最后还原排好序的数组\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; struct MergeSort { // 主排序函数 void sort(std::vector\u0026lt;int\u0026gt;\u0026amp; arr) { if (!arr.empty()) { mergeSort(arr, 0, arr.size() - 1); } } private: // 合并两个已排序的子数组 void merge(std::vector\u0026lt;int\u0026gt;\u0026amp; arr, int left, int mid, int right) { int n1 = mid - left + 1; // 左子数组的大小 int n2 = right - mid; // 右子数组的大小 std::vector\u0026lt;int\u0026gt; L(n1); // 创建左子数组 std::vector\u0026lt;int\u0026gt; R(n2); // 创建右子数组 // 将数据拷贝到临时数组 L[] 和 R[] for (int i = 0; i \u0026lt; n1; i++) L[i] = arr[left + i]; for (int j = 0; j \u0026lt; n2; j++) R[j] = arr[mid + 1 + j]; // 合并临时数组 int i = 0; // 初始索引 L int j = 0; // 初始索引 R int k = left; // 初始索引合并后的数组 while (i \u0026lt; n1 \u0026amp;\u0026amp; j \u0026lt; n2) { if (L[i] \u0026lt;= R[j]) { arr[k] = L[i]; i++; } else { arr[k] = R[j]; j++; } k++; } // 复制 L[] 中剩余的元素 while (i \u0026lt; n1) { arr[k] = L[i]; i++; k++; } // 复制 R[] 中剩余的元素 while (j \u0026lt; n2) { arr[k] = R[j]; j++; k++; } } // 归并排序函数 void mergeSort(std::vector\u0026lt;int\u0026gt;\u0026amp; arr, int left, int right) { if (left \u0026lt; right) { int mid = left + (right - left) / 2; // 递归排序左右半部分 mergeSort(arr, left, mid); mergeSort(arr, mid + 1, right); // 合并已排序的部分 merge(arr, left, mid, right); } } }; // 主函数 int main() { std::vector\u0026lt;int\u0026gt; arr = {38, 27, 43, 3, 9, 82, 10}; std::cout \u0026lt;\u0026lt; \u0026#34;原数组: \u0026#34;; for (int num : arr) { std::cout \u0026lt;\u0026lt; num \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } std::cout \u0026lt;\u0026lt; std::endl; MergeSort sorter; sorter.sort(arr); // 调用排序函数 std::cout \u0026lt;\u0026lt; \u0026#34;排序后的数组: \u0026#34;; for (int num : arr) { std::cout \u0026lt;\u0026lt; num \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } std::cout \u0026lt;\u0026lt; std::endl; return 0; } 堆排序\r算法思路\r因为建小堆可以选出最小的数即根节点，我们将每次建好的小堆的最后一个叶子节点和根节点进行交换，交换后不把最后一个数看作堆里的数据，此时根的左右子树依旧是大堆，然后我们再用向下调整算法选出次小的如此循环直到堆里剩一个数结束\n• 升序建大堆 • 降序建小堆\n代码\r堆排序(降序)实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 //降序 void HeapSort(int* a, int n) { //建小堆 for (int i = (n - 1 - 1) / 2; i \u0026gt;= 0; --i) { AdjustDown(a, n, i); } int end = n - 1; //把最小的换到最后一个位置，不把最后一个数看作堆里的 //每次选出剩下数中最小的 //从后往前放 while (end \u0026gt; 0) { int tem = a[end]; a[end] = a[0]; a[0] = tem; //选出次小的数 AdjustDown(a, end, 0); --end; } } 最坏的情况及满二叉树，且每个节点都需要调整\n由以上推论过程可得建堆的时间复杂度为$O(N)$; 向下调整算法的时间复杂度为$O(log_2N$); 所以堆排序的时间复杂度为$O(Nlog_2N$);\n快速排序\r快排的实现方法有三种，逐一介绍：\nhoare版本(左右指针法)\r算法思路\r1、选出一个key，一般是最左边或是最右边的。 2、定义一个begin和一个end，begin从左向右走，end从右向左走。（需要注意的是：若选择最左边的数据作为key，则需要end先走；若选择最右边的数据作为key，则需要begin先走）。 3、在走的过程中，若end遇到小于key的数，则停下，begin开始走，直到begin遇到一个大于key的数时，将begin和right的内容交换，end再次开始走，如此进行下去，直到begin和end最终相遇，此时将相遇点的内容与key交换即可。（选取最左边的值作为key） 4.此时key的左边都是小于key的数，key的右边都是大于key的数 5.将key的左序列和右序列再次进行这种单趟排序，如此反复操作下去，直到左右序列只有一个数据，或是左右序列不存在时，便停止操作，此时此部分已有序\n单趟动图如下：\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 //快速排序 hoare版本(左右指针法) void QuickSort(int* arr, int begin, int end) { //只有一个数或区间不存在 if (begin \u0026gt;= end) return; int left = begin; int right = end; //选左边为key int keyi = begin; while (begin \u0026lt; end) { //右边选小 等号防止和key值相等 防止顺序begin和end越界 while (arr[end] \u0026gt;= arr[keyi] \u0026amp;\u0026amp; begin \u0026lt; end) { --end; } //左边选大 while (arr[begin] \u0026lt;= arr[keyi] \u0026amp;\u0026amp; begin \u0026lt; end) { ++begin; } //小的换到右边，大的换到左边 swap(\u0026amp;arr[begin], \u0026amp;arr[end]); } swap(\u0026amp;arr[keyi], \u0026amp;arr[end]); keyi = end; //[left,keyi-1]keyi[keyi+1,right] QuickSort(arr, left, keyi - 1); QuickSort(arr,keyi + 1,right); } 挖坑法\r代码可分为递归和非递归两种\n算法思路\r挖坑法思路与hoare版本(左右指针法)思路类似 1.选出一个数据（一般是最左边或是最右边的）存放在key变量中，在该数据位置形成一个坑 2、还是定义一个L和一个R，L从左向右走，R从右向左走。（若在最左边挖坑，则需要R先走；若在最右边挖坑，则需要L先走）\n单趟动图如下：\n代码可分为递归和非递归两种\n递归算法代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 //快速排序法 挖坑法 void QuickSort1(int* arr, int begin, int end) { if (begin \u0026gt;= end) return; int left = begin,right = end; int key = arr[begin]; while (begin \u0026lt; end) { //找小 while (arr[end] \u0026gt;= key \u0026amp;\u0026amp; begin \u0026lt; end) { --end; } //小的放到左边的坑里 arr[begin] = arr[end]; //找大 while (arr[begin] \u0026lt;= key \u0026amp;\u0026amp; begin \u0026lt; end) { ++begin; } //大的放到右边的坑里 arr[end] = arr[begin]; } arr[begin] = key; int keyi = begin; //[left,keyi-1]keyi[keyi+1,right] QuickSort1(arr, left, keyi - 1); QuickSort1(arr, keyi + 1, right); } 非递归算法代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 //单趟排 int PartSort(int* arr, int begin, int end) { int key = arr[begin]; while (begin \u0026lt; end) { while (key \u0026lt;= arr[end] \u0026amp;\u0026amp; begin \u0026lt; end) { --end; } arr[begin] = arr[end]; while (key \u0026gt;= arr[begin] \u0026amp;\u0026amp; begin \u0026lt; end) { ++begin; } arr[end] = arr[begin]; } arr[begin] = key; int meeti = begin; return meeti; } void QuickSortNoR(int* arr, int begin, int end) { stack\u0026lt;int\u0026gt; st; //先入右边 st.push(end); //再入左边 st.push(begin); while (!st.empty()) { //左区间 int left = st.top(); st.pop(); //右区间 int right = st.top(); st.pop(); //中间数 int mid = PartSort(arr, left, right); //当左区间\u0026gt;=mid-1则证明左区间已经排好序了 if (left \u0026lt; mid - 1) { st.push(mid - 1); st.push(left); } //当mid+1\u0026gt;=右区间则证明右区间已经排好序 if (right \u0026gt; mid + 1) { st.push(right); st.push(mid + 1); } } } 前后指针法\r算法思路\r1、选出一个key，一般是最左边或是最右边的。 2、起始时，prev指针指向序列开头，cur指针指向prev+1。 3、若cur指向的内容小于key，则prev先向后移动一位，然后交换prev和cur指针指向的内容，然后cur指针++；若cur指向的内容大于key，则cur指针直接++。如此进行下去，直到cur到达end位置，此时将key和++prev指针指向的内容交换即可。\n经过一次单趟排序，最终也能使得key左边的数据全部都小于key，key右边的数据全部都大于key。\n然后也还是将key的左序列和右序列再次进行这种单趟排序，如此反复操作下去，直到左右序列只有一个数据，或是左右序列不存在时，便停止操作\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 //快速排序法 前后指针版本 void QuickSort2(int* arr, int begin, int end) { if (begin \u0026gt;= end) return; int cur = begin, prev = begin - 1; int keyi = end; while (cur != keyi) { if (arr[cur] \u0026lt; arr[keyi] \u0026amp;\u0026amp; ++prev != cur) { swap(\u0026amp;arr[cur], \u0026amp;arr[prev]); } ++cur; } swap(\u0026amp;arr[++prev],\u0026amp;arr[keyi]); keyi = prev; //[begin,keyi -1]keyi[keyi+1,end] QuickSort2(arr, begin, keyi - 1); QuickSort2(arr, keyi + 1, end); } 一句话总结：快速排序的模糊解释就是先选择一个元素作为标准元素key，让比key小的放在key左边，比key大的放在key右边，最后在key的两边分别做相同的排序，得到最终排序结果\n","date":"2024-12-09T00:11:27+08:00","permalink":"https://fsj2009yx.github.io/posts/post_251061473025222/","title":"排序算法"},{"content":"异或和之和\rP9236 \\[蓝桥杯 2023 省 A\\] 异或和之和 - 洛谷 | 计算机科学教育新生态\n问题\r给定一个数组 $A_i$，分别求其每个子段的异或和，并求出它们的和。或者说，对于每组满足 $1 \\leq L \\leq R \\leq n$ 的 $L,R$，求出数组中第 $L$ 至第 $R$ 个元素的异或和。然后输出每组 $L,R$ 得到的结果加起来的值。\n输入格式\r输入的第一行包含一个整数 $n$ 。\n第二行包含 $n$ 个整数 $A_i$，相邻整数之间使用一个空格分隔。\n输出格式\r输出一行包含一个整数表示答案。\n样例 #1\r样例输入 #1\r1 2 5 1 2 3 4 5 样例输出 #1\r1 39 提示\r【评测用例规模与约定】\r对于 $30 %$ 的评测用例，$n \\leq 300$；\n对于 $60 %$ 的评测用例，$n \\leq 5000$;\n对于所有评测用例，$1 \\leq n \\leq 10^5$，$0 \\leq A_i \\leq 2^{20}$。\n我的解答（未AC）\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;bits/stdc++.h\u0026gt; typedef long long ll; using namespace std; int a[100001]; int b[100001] = {0}; int main() { ios::sync_with_stdio(false); cin.tie(0), cout.tie(0); int n; cin \u0026gt;\u0026gt; n; ll ans = 0; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; a[i]; b[i] = b[i - 1] ^ a[i]; ans += b[i]; } for (int i = n; i \u0026gt;= 1; i--) { for (int j = 1; j \u0026lt; i; j++) { if (b[i] == b[j]) { continue; } else { ans += (b[i] ^ b[j]); } } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } 通过异或前缀和数组暴力枚举算出ans，时间复杂度为O（n²），只能拿到60分\n优化\r要对前缀异或数组中元素两两异或的时间复杂度$O(n^2)$进行优化，考虑到异或的性质，我们可以选择将整数转为二进制，按位运算：\n1 2 3 4 for (int j = 0; j \u0026lt;= 20; ++j) { a[i][j] = (x \u0026gt;\u0026gt; j) \u0026amp; 1; a[i][j] ^= a[i - 1][j]; } 考虑到数字的范围$2^{20}$，我们开a[20]来存每一个元素的每一位；\na[i][j] = (x \u0026gt;\u0026gt; j) \u0026amp; 1;的作用是求出x二进制的每一位，方法是先右移再和1做位与运算 a[i][j] ^= a[i - 1][j];即在每一位上求异或前缀和 现在求得了所有元素的异或前缀和数组，这样我们可以在每一位上两两异或并累加求得该位的区间异或和 这里我们使用空间换时间的方式，将$n^2$压缩到$n$：\n1 2 3 4 5 6 7 8 9 for (int j = 0; j \u0026lt;= 20; ++j) { map\u0026lt;int, int\u0026gt; m; m[0]++; for (int i = 1; i \u0026lt;= n; ++i) { int x = m[a[i][j] ^ 1]; ans += 1LL * (1 \u0026lt;\u0026lt; j) * x; m[a[i][j]]++; } } 这里对代码进行逐行解释：\n1 int x = m[a[i][j] ^ 1] a[i][j] ^ 1是对该位取反，属于异或运算的基本应用 如果异或和区间在该位上的元素（0、1）想对最终结果做出贡献，就必须让$a_i\\oplus a_{i+1}\\oplus\u0026hellip;\\oplus a_m$的结果为$1$，在异或前缀和上就是$b_{i-1}\\oplus b_{m} $的结果为$1$：由于这里只有$0、1$两个元素，某个元素的异或就是另一个元素，我们使用map（vector[2]同理）来存储0和1的出现次数，以空间换时间; x即与a[i][j]异或值为1的元素个数 1 2 ans += 1LL * (1 \u0026lt;\u0026lt; j) * x; m[a[i][j]]++; (1 \u0026lt;\u0026lt; j) * x;对1左移$j$位再乘上x,即异或前缀和元素在该位上两两异或为1的总次数，并将其还原成十进制计算结果\nm[a[i][j]]++记录该位，用于后续该位元素的计算\n通过这种方法，我们将时间复杂度$O(n^2)$压缩到了$O(20n)$，成功AC\n总结\r这道题的思路在于，题目给出了$A_i$元素的范围$2^{20}$，提示了我们可以将他转换成二进制数，也就是拆位；\n又因为每一位只可能是1或0，我们可以借助长度为2的数组对记录元素出现的次数，避免了双重循环\n","date":"2024-12-07T23:20:47+08:00","permalink":"https://fsj2009yx.github.io/posts/post_279452484721406/","title":"异或和之和"},{"content":"三门问题的python代码模拟和原理解释\r刷视频时偶然刷到了三门问题，于是好奇的查阅了一下\n先给出三门问题的简单介绍（引用自百度）：\n三门问题（Monty Hall problem）亦称为蒙提霍尔问题、蒙特霍问题或蒙提霍尔悖论，大致出自美国的电视游戏节目Let\u0026rsquo;s Make a Deal。问题名字来自该节目的主持人蒙提·霍尔（Monty Hall）。\n参赛者会看见三扇关闭了的门，其中一扇的后面有一辆汽车，选中后面有车的那扇门可赢得该汽车，另外两扇门后面则各藏有一只山羊。\n当参赛者选定了一扇门，但未去开启它的时候，节目主持人开启剩下两扇门的其中一扇，露出其中一只山羊。 主持人其后会问参赛者要不要换另一扇仍然关上的门。问题是：换另一扇门会否增加参赛者赢得汽车的机率。如果严格按照上述的条件，那么答案是会。不换门的话，赢得汽车的几率是1/3。换门的话，赢得汽车的几率是2/3。 虽然该问题的答案在逻辑上并不自相矛盾，但十分违反直觉。\n开始和大多数人想的一样，会选择继续开第一扇门或者认为换和不换的概率都为$1/2$，答案显然不是。\n为更直观的看到三门问题的正确性，我写了一段python代码模拟这个过程\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import random num :int =10000000 doors=[\u0026#39;sheep\u0026#39;,\u0026#39;sheep\u0026#39;,\u0026#39;car\u0026#39;] win_num :int =0 for i in range(num): random.shuffle(doors) #随机打乱 #首先选择第一个门，主持人开启另一个门 #choice=doors[0] #展示另一个门为山羊 if doors[1]==\u0026#39;sheep\u0026#39;: sheep=doors[1] index=2 else: sheep=doors[2] index=1 #选择换门 choice=doors[index] if choice==\u0026#39;car\u0026#39;: win_num+=1 print(f\u0026#34;获奖的概率为{win_num/num*100}%\u0026#34;) 经过多次运行，在$10000000$次试验的环境下，最后的输出结果接近于$66.7%$，也就是$2/3$\n原理解释\r很显然这是一个概率论的问题，我们来构建更加具体的概率问题：\n问题简述：\n有三扇门，其中一扇门后面藏有一辆车，另外两扇门后面藏有山羊。 你首先选择一扇门。 主持人知道哪个门后面有车，之后会打开一扇没有车的门，通常是两扇你没选的门中的一扇。 然后主持人会问你是否要换门。如果你换门，你会选择剩下的未被你选中且未被主持人打开的门。 问题是：是否换门能增加获胜的概率？\n假定选手选择第一扇门\nA=第一扇门中是车 B=第二扇门中是车 C=第三扇门中是车 D=主持人选择打开第三扇门 在初始情况下：$P(A)=P(B)=P(C)=1/3$;\n然后，主持人打开了第三扇门，且我们知道第三扇门后面是山羊。\n此时注意：由于主持人并不是固定打开三号门，主持人需要选择不是车的那个门来打开，只是在事例中，我们事先假定了三号门为羊\n如果第一扇门后面有车（事件A），也就是说主持人选择第二扇门和第三扇门都可以。所以，在事件A下，主持人选择打开第三扇门的概率是 $P(D|A)=1/2$，\n如果第二扇门后面有车（事件B），主持人只能打开第三扇门（因为第三扇门后有山羊）。因此，在事件B下，主持人打开第三扇门的概率是 1,即$P(D|B)=1$\n如果第三扇门后面有车（事件C），主持人就不能打开第三扇门了。因此，在事件C下，主持人只能选择打开第二扇门，$P(D|B)=0$\n现在我们需要计算在主持人打开第三扇门的情况下，是否换门能够增加获胜的概率：\n在换门的情况下，最终选择第二扇门 由贝叶斯公式，计算$P(B | D) = \\frac{P(D | B)P(B)}{P(D)}$ 由全概率公式，计算$P(D)$=$P(D|A)P(A)+P(D|B)P(B)+P(D|C)P(C)=(1/21/3)+11/3+0=1/2$; 由上面的条件知：$P(B | D) = \\frac{P(D | B)P(B)}{P(D)}=(1*1/3)/(1/2)=2/3$;\n由此我们得知，在主持人打开了第三扇门的条件下，我们选择第二扇门的概率为$2/3$，因此，我们换门的获奖几率更大\n总结\r在这个场景中，我在思考主持人选择第三扇门的部分耗费了不少时间，原因是我没有理解到，主持人并不是固定打开三号门，只是在问题场景中打开了第三扇门，而第三扇门恰好为羊。而实际上，主持人为了保证打开结果为羊的门，是否打开三号门是根据门后的物品排放来决定的。\n","date":"2024-12-06T19:10:09+08:00","permalink":"https://fsj2009yx.github.io/posts/post_243711766418750/","title":"三门问题的python代码模拟和原理解释"}]