[{"content":"排序算法\r插入排序\r算法思路\r从第一个元素开始，该元素可以认为已经被排序 取下一个元素tem，从已排序的元素序列从后往前扫描 如果该元素大于tem，则将该元素移到下一位 重复步骤3，直到找到已排序元素中小于等于tem的元素 tem插入到该元素的后面，如果已排序所有元素都大于tem，则将tem插入到下标为0的位置 重复步骤2~5 一句话总结：每次取第$i+1$个元素，依次与前一个元素比较直到找到一个比它小的元素，插入到它的后面\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 void InsertSort(int* arr, int n) { for (int i = 0; i \u0026lt; n - 1; ++i) { //记录有序序列最后一个元素的下标 int end = i; //待插入的元素 int tem = arr[end + 1]; //单趟排 while (end \u0026gt;= 0) { //比插入的数大就向后移 if (tem \u0026lt; arr[end]) { arr[end + 1] = arr[end]; end--; } //比插入的数小，跳出循环 else { break; } } //tem放到比插入的数小的数的后面 arr[end + 1] = tem; //代码执行到此位置有两种情况: //1.待插入元素找到应插入位置（break跳出循环到此） //2.待插入元素比当前有序序列中的所有元素都小（while循环结束后到此） } } 时间复杂度：最坏情况下为O(N²)，此时待排序列为逆序，或者说接近逆序\n最好情况下为O(N)，此时待排序列为升序，或者说接近升序。\n空间复杂度：O(1)\n希尔排序\r思路：\n先选定一个小于N的gap作为第一增量，然后将所有距离为gap的元素分在同一组，并对每一组的元素进行直接插入排序。然后再取一个比第一增量小的整数作为第二增量，重复上述操作 当增量的大小减到1时，就相当于整个序列被分到一组，进行一次直接插入排序，排序完成。 一句话总结：第一次取gap=n/2，然后距离为gap的两个元素按照大小顺序决定是否交换，然后第二次取gap=gap/2，以此类推，直到gap减小到1，进行一次直接插入排序，排序完成\n如上图所示，在初始位置gap=10/2=5，将距离为5的元素分在同一组，即（8，3）、（9，5）、（1，4）、（7，6）、（2、0），每组内的两个元素比较后依照插入排序更新位置 排序结束后取gap/=2，以相同方法再次排序\n代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 //希尔排序 void ShellSort(int* arr, int n) { int gap = n; while (gap\u0026gt;1) { //每次对gap折半操作 gap = gap / 2; //单趟排序 for (int i = 0; i \u0026lt; n - gap; ++i) { int end = i; int tem = arr[end + gap]; while (end \u0026gt;= 0) { if (tem \u0026lt; arr[end]) { arr[end + gap] = arr[end]; end -= gap; } else { break; } } arr[end + gap] = tem; } } } 时间复杂度（平均）：O（N^1.3） 空间复杂度：O（1）\n选择排序\r思路： 每次从待排序列中选出一个最小值，然后放在序列的起始位置，直到全部待排数据排完即可。 实际上，我们可以一趟选出两个值，一个最大值一个最小值，然后将其放在序列开头和末尾，这样可以使选择排序的效率快一倍。\n一句话总结：每趟选出一个最小放在前面，一直排到末尾；\n我们可以一趟选出两个值，一个最大值一个最小值，然后将其放在序列开头和末尾，效率更快\n代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 //选择排序 void swap(int* a, int* b) { int tem = *a; *a = *b; *b = tem; } void SelectSort(int* arr, int n) { //保存参与单趟排序的第一个数和最后一个数的下标 int begin = 0, end = n - 1; while (begin \u0026lt; end) { //保存最大值的下标 int maxi = begin; //保存最小值的下标 int mini = begin; //找出最大值和最小值的下标 for (int i = begin; i \u0026lt;= end; ++i) { if (arr[i] \u0026lt; arr[mini]) { mini = i; } if (arr[i] \u0026gt; arr[maxi]) { maxi = i; } } //最小值放在序列开头 swap(\u0026amp;arr[mini], \u0026amp;arr[begin]); //防止最大的数在begin位置被换走 if (begin == maxi) { maxi = mini; } //最大值放在序列结尾 swap(\u0026amp;arr[maxi], \u0026amp;arr[end]); ++begin; --end; } } 时间复杂度：最坏情况：O(N^2)\n最好情况：O(N^2)\n空间复杂度：O(1)\n计数排序\r计数排序是一种非比较排序，其核心是将序列中的元素作为键存储在额外的数组空间中，而该元素的个数作为值存储在数组空间中，通过遍历该数组排序。\n计数排序的应用场景\r序列中最大值和最小值之间的差值不能过大，这主要是防止建立数组时造成内存的浪费。 序列中存在的元素是整数，因为我们使用的是该元素作为键存储在额外的数组空间中，如果不是整数，不能作为键。 代码\r创建临时数组\r我们先创建一个临时的数组tmp并且该数组的最大下标为原数组中元素的最大值（里面的元素初始化为0）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 //先遍历原数组找到最大值 int max = a[0]; for (int i = 1; i \u0026lt; n; i++) { if (max \u0026lt; a[i]) { max = a[i]; } } //动态内存开辟max+1个int空间并初始化为0用calloc int* tmp = (int)calloc(max+1, sizeof(int)); if (tmp == NULL) { perror(\u0026#34;calloc fail!\\n\u0026#34;); return; } 统计次数\r然后遍历一遍原数组，原数组中出现哪个元素就在tmp数组中与该元素数值相同的下标对应的地方进行加加操作来记录该元素出现的次数。\n1 2 3 4 5 //统计次数 for (int i = 0; i \u0026lt; n; i++) { tmp[a[i]]++; } 排序\r最后我们再进行排序，记住tmp的下标对应原数组可能出现的元素，而里面的值对应该元素出现的次数，如果为0就说明该元素在原数组不存在。遍历tmp数组，将对应的下标覆盖原数组即可完成排序。\n1 2 3 4 5 6 7 8 9 10 11 12 //排序 int j = 0; for (int i = 0; i \u0026lt; max + 1; i++)//第一层循环遍历tmp数组 { while (tmp[i]--)//对应元素出现的次数 { a[j++] = i;//tmp的下标对应的就是原数组可能出现的元素 } } //释放资源，避免内存泄漏 free(tmp); tmp = NULL; 简单版本\r完整代码如下：(c++版本)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;iterator\u0026gt; void CountSort(std::vector\u0026lt;int\u0026gt;\u0026amp; a) { // 如果数组为空，直接返回 if (a.empty()) return; // 使用std::max_element找到数组中的最大值 int max = *std::max_element(a.begin(), a.end()); // 创建一个大小为(max + 1)的数组，初始值都为0 std::vector\u0026lt;int\u0026gt; tmp(max + 1, 0); // 统计每个元素的出现次数 for (int num : a) { tmp[num]++; } // 排序阶段 int j = 0; // 遍历tmp数组，按照每个元素出现的次数重新填充原数组a for (int i = 0; i \u0026lt;= max; ++i) { // 当tmp[i]不为0时，将i填充到a数组中tmp[i]次 while (tmp[i]--) { a[j++] = i; } } } int main() { // 示例数组 std::vector\u0026lt;int\u0026gt; arr = {4, 2, 2, 8, 3, 3, 1}; // 调用计数排序函数 CountSort(arr); // 输出排序后的数组 for (int num : arr) { std::cout \u0026lt;\u0026lt; num \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } std::cout \u0026lt;\u0026lt; std::endl; return 0; } 优化\r如果我们的数据是这样的，如果还像之前那样开辟空间，会有大量的空间浪费遍历的次数增大，就存在性能的降低 如图，数据的最小值为100，而按照原代码则浪费了0-100中的数组空间，导致不必要的内存开销\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; void CountSort(std::vector\u0026lt;int\u0026gt;\u0026amp; a) { if (a.empty()) return; // 使用std::min和std::max找出数组的最小值和最大值 int min = *std::min_element(a.begin(), a.end()); int max = *std::max_element(a.begin(), a.end()); int range = max - min + 1; // 创建一个大小为range的vector，初始化为0 std::vector\u0026lt;int\u0026gt; tmp(range, 0); // 统计每个元素出现的次数 for (int num : a) { tmp[num - min]++; } // 排序阶段 int j = 0; for (int i = 0; i \u0026lt; range; ++i) { // 将tmp[i]个i+min值填充到a中 while (tmp[i]--) { a[j++] = i + min; } } } int main() { // 示例数组 std::vector\u0026lt;int\u0026gt; arr = {4, 2, 2, 8, 3, 3, 1}; // 调用计数排序函数 CountSort(arr); // 输出排序后的数组 for (int num : arr) { std::cout \u0026lt;\u0026lt; num \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } std::cout \u0026lt;\u0026lt; std::endl; return 0; } 空间复杂度：除原数组外，计数排序额外开辟了一个大小为N的临时空间，所以计数排序的空间复杂度为O(N)。 时间复杂度：遍历找最大最小值取范围的时间复杂度为O(N)，遍历原数组统计次数的时间复杂度为O(N)，而排序里面，虽有两层循环，但从思想和本质来看，它只不过是将原来的元素按顺序覆盖了原数组，其执行循环的次数任然为O(N)，所以计数排序的时间复杂度为O(N).\n归并排序\r算法思路\r归并排序算法有两个基本的操作，一个是分，也就是把原数组划分成两个子数组的过程。另一个是治，它将两个有序数组合并成一个更大的有序数组。\n将待排序的线性表不断地切分成若干个子表，直到每个子表只包含一个元素，这时，可以认为只包含一个元素的子表是有序表。 将子表两两合并，每合并一次，就会产生一个新的且更长的有序表，重复这一步骤，直到最后只剩下一个子表，这个子表就是排好序的线性表。\n一句话总结：第一次分为两组，第二次每一组又分为两组，也就是$2^2=4$组，以此类推，直到每组的元素个数为1；\n按照大小顺序逐个合并，最后还原排好序的数组\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; struct MergeSort { // 主排序函数 void sort(std::vector\u0026lt;int\u0026gt;\u0026amp; arr) { if (!arr.empty()) { mergeSort(arr, 0, arr.size() - 1); } } private: // 合并两个已排序的子数组 void merge(std::vector\u0026lt;int\u0026gt;\u0026amp; arr, int left, int mid, int right) { int n1 = mid - left + 1; // 左子数组的大小 int n2 = right - mid; // 右子数组的大小 std::vector\u0026lt;int\u0026gt; L(n1); // 创建左子数组 std::vector\u0026lt;int\u0026gt; R(n2); // 创建右子数组 // 将数据拷贝到临时数组 L[] 和 R[] for (int i = 0; i \u0026lt; n1; i++) L[i] = arr[left + i]; for (int j = 0; j \u0026lt; n2; j++) R[j] = arr[mid + 1 + j]; // 合并临时数组 int i = 0; // 初始索引 L int j = 0; // 初始索引 R int k = left; // 初始索引合并后的数组 while (i \u0026lt; n1 \u0026amp;\u0026amp; j \u0026lt; n2) { if (L[i] \u0026lt;= R[j]) { arr[k] = L[i]; i++; } else { arr[k] = R[j]; j++; } k++; } // 复制 L[] 中剩余的元素 while (i \u0026lt; n1) { arr[k] = L[i]; i++; k++; } // 复制 R[] 中剩余的元素 while (j \u0026lt; n2) { arr[k] = R[j]; j++; k++; } } // 归并排序函数 void mergeSort(std::vector\u0026lt;int\u0026gt;\u0026amp; arr, int left, int right) { if (left \u0026lt; right) { int mid = left + (right - left) / 2; // 递归排序左右半部分 mergeSort(arr, left, mid); mergeSort(arr, mid + 1, right); // 合并已排序的部分 merge(arr, left, mid, right); } } }; // 主函数 int main() { std::vector\u0026lt;int\u0026gt; arr = {38, 27, 43, 3, 9, 82, 10}; std::cout \u0026lt;\u0026lt; \u0026#34;原数组: \u0026#34;; for (int num : arr) { std::cout \u0026lt;\u0026lt; num \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } std::cout \u0026lt;\u0026lt; std::endl; MergeSort sorter; sorter.sort(arr); // 调用排序函数 std::cout \u0026lt;\u0026lt; \u0026#34;排序后的数组: \u0026#34;; for (int num : arr) { std::cout \u0026lt;\u0026lt; num \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } std::cout \u0026lt;\u0026lt; std::endl; return 0; } 堆排序\r算法思路\r因为建小堆可以选出最小的数即根节点，我们将每次建好的小堆的最后一个叶子节点和根节点进行交换，交换后不把最后一个数看作堆里的数据，此时根的左右子树依旧是大堆，然后我们再用向下调整算法选出次小的如此循环直到堆里剩一个数结束\n• 升序建大堆 • 降序建小堆\n代码\r堆排序(降序)实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 //降序 void HeapSort(int* a, int n) { //建小堆 for (int i = (n - 1 - 1) / 2; i \u0026gt;= 0; --i) { AdjustDown(a, n, i); } int end = n - 1; //把最小的换到最后一个位置，不把最后一个数看作堆里的 //每次选出剩下数中最小的 //从后往前放 while (end \u0026gt; 0) { int tem = a[end]; a[end] = a[0]; a[0] = tem; //选出次小的数 AdjustDown(a, end, 0); --end; } } 最坏的情况及满二叉树，且每个节点都需要调整\n由以上推论过程可得建堆的时间复杂度为$O(N)$; 向下调整算法的时间复杂度为$O(log_2N$); 所以堆排序的时间复杂度为$O(Nlog_2N$);\n快速排序\r快排的实现方法有三种，逐一介绍：\nhoare版本(左右指针法)\r算法思路\r1、选出一个key，一般是最左边或是最右边的。 2、定义一个begin和一个end，begin从左向右走，end从右向左走。（需要注意的是：若选择最左边的数据作为key，则需要end先走；若选择最右边的数据作为key，则需要begin先走）。 3、在走的过程中，若end遇到小于key的数，则停下，begin开始走，直到begin遇到一个大于key的数时，将begin和right的内容交换，end再次开始走，如此进行下去，直到begin和end最终相遇，此时将相遇点的内容与key交换即可。（选取最左边的值作为key） 4.此时key的左边都是小于key的数，key的右边都是大于key的数 5.将key的左序列和右序列再次进行这种单趟排序，如此反复操作下去，直到左右序列只有一个数据，或是左右序列不存在时，便停止操作，此时此部分已有序\n单趟动图如下：\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 //快速排序 hoare版本(左右指针法) void QuickSort(int* arr, int begin, int end) { //只有一个数或区间不存在 if (begin \u0026gt;= end) return; int left = begin; int right = end; //选左边为key int keyi = begin; while (begin \u0026lt; end) { //右边选小 等号防止和key值相等 防止顺序begin和end越界 while (arr[end] \u0026gt;= arr[keyi] \u0026amp;\u0026amp; begin \u0026lt; end) { --end; } //左边选大 while (arr[begin] \u0026lt;= arr[keyi] \u0026amp;\u0026amp; begin \u0026lt; end) { ++begin; } //小的换到右边，大的换到左边 swap(\u0026amp;arr[begin], \u0026amp;arr[end]); } swap(\u0026amp;arr[keyi], \u0026amp;arr[end]); keyi = end; //[left,keyi-1]keyi[keyi+1,right] QuickSort(arr, left, keyi - 1); QuickSort(arr,keyi + 1,right); } 挖坑法\r代码可分为递归和非递归两种\n算法思路\r挖坑法思路与hoare版本(左右指针法)思路类似 1.选出一个数据（一般是最左边或是最右边的）存放在key变量中，在该数据位置形成一个坑 2、还是定义一个L和一个R，L从左向右走，R从右向左走。（若在最左边挖坑，则需要R先走；若在最右边挖坑，则需要L先走）\n单趟动图如下：\n代码可分为递归和非递归两种\n递归算法代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 //快速排序法 挖坑法 void QuickSort1(int* arr, int begin, int end) { if (begin \u0026gt;= end) return; int left = begin,right = end; int key = arr[begin]; while (begin \u0026lt; end) { //找小 while (arr[end] \u0026gt;= key \u0026amp;\u0026amp; begin \u0026lt; end) { --end; } //小的放到左边的坑里 arr[begin] = arr[end]; //找大 while (arr[begin] \u0026lt;= key \u0026amp;\u0026amp; begin \u0026lt; end) { ++begin; } //大的放到右边的坑里 arr[end] = arr[begin]; } arr[begin] = key; int keyi = begin; //[left,keyi-1]keyi[keyi+1,right] QuickSort1(arr, left, keyi - 1); QuickSort1(arr, keyi + 1, right); } 非递归算法代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 //单趟排 int PartSort(int* arr, int begin, int end) { int key = arr[begin]; while (begin \u0026lt; end) { while (key \u0026lt;= arr[end] \u0026amp;\u0026amp; begin \u0026lt; end) { --end; } arr[begin] = arr[end]; while (key \u0026gt;= arr[begin] \u0026amp;\u0026amp; begin \u0026lt; end) { ++begin; } arr[end] = arr[begin]; } arr[begin] = key; int meeti = begin; return meeti; } void QuickSortNoR(int* arr, int begin, int end) { stack\u0026lt;int\u0026gt; st; //先入右边 st.push(end); //再入左边 st.push(begin); while (!st.empty()) { //左区间 int left = st.top(); st.pop(); //右区间 int right = st.top(); st.pop(); //中间数 int mid = PartSort(arr, left, right); //当左区间\u0026gt;=mid-1则证明左区间已经排好序了 if (left \u0026lt; mid - 1) { st.push(mid - 1); st.push(left); } //当mid+1\u0026gt;=右区间则证明右区间已经排好序 if (right \u0026gt; mid + 1) { st.push(right); st.push(mid + 1); } } } 前后指针法\r算法思路\r1、选出一个key，一般是最左边或是最右边的。 2、起始时，prev指针指向序列开头，cur指针指向prev+1。 3、若cur指向的内容小于key，则prev先向后移动一位，然后交换prev和cur指针指向的内容，然后cur指针++；若cur指向的内容大于key，则cur指针直接++。如此进行下去，直到cur到达end位置，此时将key和++prev指针指向的内容交换即可。\n经过一次单趟排序，最终也能使得key左边的数据全部都小于key，key右边的数据全部都大于key。\n然后也还是将key的左序列和右序列再次进行这种单趟排序，如此反复操作下去，直到左右序列只有一个数据，或是左右序列不存在时，便停止操作\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 //快速排序法 前后指针版本 void QuickSort2(int* arr, int begin, int end) { if (begin \u0026gt;= end) return; int cur = begin, prev = begin - 1; int keyi = end; while (cur != keyi) { if (arr[cur] \u0026lt; arr[keyi] \u0026amp;\u0026amp; ++prev != cur) { swap(\u0026amp;arr[cur], \u0026amp;arr[prev]); } ++cur; } swap(\u0026amp;arr[++prev],\u0026amp;arr[keyi]); keyi = prev; //[begin,keyi -1]keyi[keyi+1,end] QuickSort2(arr, begin, keyi - 1); QuickSort2(arr, keyi + 1, end); } 一句话总结：快速排序的模糊解释就是先选择一个元素作为标准元素key，让比key小的放在key左边，比key大的放在key右边，最后在key的两边分别做相同的排序，得到最终排序结果\n","date":"2024-12-09T00:11:27+08:00","permalink":"https://fsj2009yx.github.io/posts/post_251061473025222/","title":"排序算法"},{"content":"异或和之和\rP9236 \\[蓝桥杯 2023 省 A\\] 异或和之和 - 洛谷 | 计算机科学教育新生态\n问题\r给定一个数组 $A_i$，分别求其每个子段的异或和，并求出它们的和。或者说，对于每组满足 $1 \\leq L \\leq R \\leq n$ 的 $L,R$，求出数组中第 $L$ 至第 $R$ 个元素的异或和。然后输出每组 $L,R$ 得到的结果加起来的值。\n输入格式\r输入的第一行包含一个整数 $n$ 。\n第二行包含 $n$ 个整数 $A_i$，相邻整数之间使用一个空格分隔。\n输出格式\r输出一行包含一个整数表示答案。\n样例 #1\r样例输入 #1\r1 2 5 1 2 3 4 5 样例输出 #1\r1 39 提示\r【评测用例规模与约定】\r对于 $30 %$ 的评测用例，$n \\leq 300$；\n对于 $60 %$ 的评测用例，$n \\leq 5000$;\n对于所有评测用例，$1 \\leq n \\leq 10^5$，$0 \\leq A_i \\leq 2^{20}$。\n我的解答（未AC）\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;bits/stdc++.h\u0026gt; typedef long long ll; using namespace std; int a[100001]; int b[100001] = {0}; int main() { ios::sync_with_stdio(false); cin.tie(0), cout.tie(0); int n; cin \u0026gt;\u0026gt; n; ll ans = 0; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; a[i]; b[i] = b[i - 1] ^ a[i]; ans += b[i]; } for (int i = n; i \u0026gt;= 1; i--) { for (int j = 1; j \u0026lt; i; j++) { if (b[i] == b[j]) { continue; } else { ans += (b[i] ^ b[j]); } } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } 通过异或前缀和数组暴力枚举算出ans，时间复杂度为O（n²），只能拿到60分\n优化\r要对前缀异或数组中元素两两异或的时间复杂度$O(n^2)$进行优化，考虑到异或的性质，我们可以选择将整数转为二进制，按位运算：\n1 2 3 4 for (int j = 0; j \u0026lt;= 20; ++j) { a[i][j] = (x \u0026gt;\u0026gt; j) \u0026amp; 1; a[i][j] ^= a[i - 1][j]; } 考虑到数字的范围$2^{20}$，我们开a[20]来存每一个元素的每一位；\na[i][j] = (x \u0026gt;\u0026gt; j) \u0026amp; 1;的作用是求出x二进制的每一位，方法是先右移再和1做位与运算 a[i][j] ^= a[i - 1][j];即在每一位上求异或前缀和 现在求得了所有元素的异或前缀和数组，这样我们可以在每一位上两两异或并累加求得该位的区间异或和 这里我们使用空间换时间的方式，将$n^2$压缩到$n$：\n1 2 3 4 5 6 7 8 9 for (int j = 0; j \u0026lt;= 20; ++j) { map\u0026lt;int, int\u0026gt; m; m[0]++; for (int i = 1; i \u0026lt;= n; ++i) { int x = m[a[i][j] ^ 1]; ans += 1LL * (1 \u0026lt;\u0026lt; j) * x; m[a[i][j]]++; } } 这里对代码进行逐行解释：\n1 int x = m[a[i][j] ^ 1] a[i][j] ^ 1是对该位取反，属于异或运算的基本应用 如果异或和区间在该位上的元素（0、1）想对最终结果做出贡献，就必须让$a_i\\oplus a_{i+1}\\oplus\u0026hellip;\\oplus a_m$的结果为$1$，在异或前缀和上就是$b_{i-1}\\oplus b_{m} $的结果为$1$：由于这里只有$0、1$两个元素，某个元素的异或就是另一个元素，我们使用map（vector[2]同理）来存储0和1的出现次数，以空间换时间; x即与a[i][j]异或值为1的元素个数 1 2 ans += 1LL * (1 \u0026lt;\u0026lt; j) * x; m[a[i][j]]++; (1 \u0026lt;\u0026lt; j) * x;对1左移$j$位再乘上x,即异或前缀和元素在该位上两两异或为1的总次数，并将其还原成十进制计算结果\nm[a[i][j]]++记录该位，用于后续该位元素的计算\n通过这种方法，我们将时间复杂度$O(n^2)$压缩到了$O(20n)$，成功AC\n总结\r这道题的思路在于，题目给出了$A_i$元素的范围$2^{20}$，提示了我们可以将他转换成二进制数，也就是拆位；\n又因为每一位只可能是1或0，我们可以借助长度为2的数组对记录元素出现的次数，避免了双重循环\n","date":"2024-12-07T23:20:47+08:00","permalink":"https://fsj2009yx.github.io/posts/post_279452484721406/","title":"异或和之和"},{"content":"三门问题的python代码模拟和原理解释\r刷视频时偶然刷到了三门问题，于是好奇的查阅了一下\n先给出三门问题的简单介绍（引用自百度）：\n三门问题（Monty Hall problem）亦称为蒙提霍尔问题、蒙特霍问题或蒙提霍尔悖论，大致出自美国的电视游戏节目Let\u0026rsquo;s Make a Deal。问题名字来自该节目的主持人蒙提·霍尔（Monty Hall）。\n参赛者会看见三扇关闭了的门，其中一扇的后面有一辆汽车，选中后面有车的那扇门可赢得该汽车，另外两扇门后面则各藏有一只山羊。\n当参赛者选定了一扇门，但未去开启它的时候，节目主持人开启剩下两扇门的其中一扇，露出其中一只山羊。 主持人其后会问参赛者要不要换另一扇仍然关上的门。问题是：换另一扇门会否增加参赛者赢得汽车的机率。如果严格按照上述的条件，那么答案是会。不换门的话，赢得汽车的几率是1/3。换门的话，赢得汽车的几率是2/3。 虽然该问题的答案在逻辑上并不自相矛盾，但十分违反直觉。\n开始和大多数人想的一样，会选择继续开第一扇门或者认为换和不换的概率都为$1/2$，答案显然不是。\n为更直观的看到三门问题的正确性，我写了一段python代码模拟这个过程\n代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import random num :int =10000000 doors=[\u0026#39;sheep\u0026#39;,\u0026#39;sheep\u0026#39;,\u0026#39;car\u0026#39;] win_num :int =0 for i in range(num): random.shuffle(doors) #随机打乱 #首先选择第一个门，主持人开启另一个门 #choice=doors[0] #展示另一个门为山羊 if doors[1]==\u0026#39;sheep\u0026#39;: sheep=doors[1] index=2 else: sheep=doors[2] index=1 #选择换门 choice=doors[index] if choice==\u0026#39;car\u0026#39;: win_num+=1 print(f\u0026#34;获奖的概率为{win_num/num*100}%\u0026#34;) 经过多次运行，在$10000000$次试验的环境下，最后的输出结果接近于$66.7%$，也就是$2/3$\n原理解释\r很显然这是一个概率论的问题，我们来构建更加具体的概率问题：\n问题简述：\n有三扇门，其中一扇门后面藏有一辆车，另外两扇门后面藏有山羊。 你首先选择一扇门。 主持人知道哪个门后面有车，之后会打开一扇没有车的门，通常是两扇你没选的门中的一扇。 然后主持人会问你是否要换门。如果你换门，你会选择剩下的未被你选中且未被主持人打开的门。 问题是：是否换门能增加获胜的概率？\n假定选手选择第一扇门\nA=第一扇门中是车 B=第二扇门中是车 C=第三扇门中是车 D=主持人选择打开第三扇门 在初始情况下：$P(A)=P(B)=P(C)=1/3$;\n然后，主持人打开了第三扇门，且我们知道第三扇门后面是山羊。\n此时注意：由于主持人并不是固定打开三号门，主持人需要选择不是车的那个门来打开，只是在事例中，我们事先假定了三号门为羊\n如果第一扇门后面有车（事件A），也就是说主持人选择第二扇门和第三扇门都可以。所以，在事件A下，主持人选择打开第三扇门的概率是 $P(D|A)=1/2$，\n如果第二扇门后面有车（事件B），主持人只能打开第三扇门（因为第三扇门后有山羊）。因此，在事件B下，主持人打开第三扇门的概率是 1,即$P(D|B)=1$\n如果第三扇门后面有车（事件C），主持人就不能打开第三扇门了。因此，在事件C下，主持人只能选择打开第二扇门，$P(D|B)=0$\n现在我们需要计算在主持人打开第三扇门的情况下，是否换门能够增加获胜的概率：\n在换门的情况下，最终选择第二扇门 由贝叶斯公式，计算$P(B | D) = \\frac{P(D | B)P(B)}{P(D)}$ 由全概率公式，计算$P(D)$=$P(D|A)P(A)+P(D|B)P(B)+P(D|C)P(C)=(1/21/3)+11/3+0=1/2$; 由上面的条件知：$P(B | D) = \\frac{P(D | B)P(B)}{P(D)}=(1*1/3)/(1/2)=2/3$;\n由此我们得知，在主持人打开了第三扇门的条件下，我们选择第二扇门的概率为$2/3$，因此，我们换门的获奖几率更大\n总结\r在这个场景中，我在思考主持人选择第三扇门的部分耗费了不少时间，原因是我没有理解到，主持人并不是固定打开三号门，只是在问题场景中打开了第三扇门，而第三扇门恰好为羊。而实际上，主持人为了保证打开结果为羊的门，是否打开三号门是根据门后的物品排放来决定的。\n","date":"2024-12-06T19:10:09+08:00","permalink":"https://fsj2009yx.github.io/posts/post_243711766418750/","title":"三门问题的python代码模拟和原理解释"}]